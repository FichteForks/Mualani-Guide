// This file is generated by rust-protobuf 3.7.1. Do not edit
// .proto file is parsed by protoc 29.0-rc1
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `AvatarNotify.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_1;

// @@protoc_insertion_point(message:Mualani.Guide.AvatarRenameInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AvatarRenameInfo {
    // message fields
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarRenameInfo.avatar_id)
    pub avatar_id: u32,
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarRenameInfo.avatar_name)
    pub avatar_name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:Mualani.Guide.AvatarRenameInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AvatarRenameInfo {
    fn default() -> &'a AvatarRenameInfo {
        <AvatarRenameInfo as ::protobuf::Message>::default_instance()
    }
}

impl AvatarRenameInfo {
    pub fn new() -> AvatarRenameInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "avatar_id",
            |m: &AvatarRenameInfo| { &m.avatar_id },
            |m: &mut AvatarRenameInfo| { &mut m.avatar_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "avatar_name",
            |m: &AvatarRenameInfo| { &m.avatar_name },
            |m: &mut AvatarRenameInfo| { &mut m.avatar_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AvatarRenameInfo>(
            "AvatarRenameInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AvatarRenameInfo {
    const NAME: &'static str = "AvatarRenameInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                48 => {
                    self.avatar_id = is.read_uint32()?;
                },
                74 => {
                    self.avatar_name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.avatar_id != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.avatar_id);
        }
        if !self.avatar_name.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.avatar_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.avatar_id != 0 {
            os.write_uint32(6, self.avatar_id)?;
        }
        if !self.avatar_name.is_empty() {
            os.write_string(9, &self.avatar_name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AvatarRenameInfo {
        AvatarRenameInfo::new()
    }

    fn clear(&mut self) {
        self.avatar_id = 0;
        self.avatar_name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AvatarRenameInfo {
        static instance: AvatarRenameInfo = AvatarRenameInfo {
            avatar_id: 0,
            avatar_name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AvatarRenameInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AvatarRenameInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AvatarRenameInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AvatarRenameInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Mualani.Guide.AvatarTeam)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AvatarTeam {
    // message fields
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarTeam.avatar_guid_list)
    pub avatar_guid_list: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarTeam.team_name)
    pub team_name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:Mualani.Guide.AvatarTeam.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AvatarTeam {
    fn default() -> &'a AvatarTeam {
        <AvatarTeam as ::protobuf::Message>::default_instance()
    }
}

impl AvatarTeam {
    pub fn new() -> AvatarTeam {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "avatar_guid_list",
            |m: &AvatarTeam| { &m.avatar_guid_list },
            |m: &mut AvatarTeam| { &mut m.avatar_guid_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "team_name",
            |m: &AvatarTeam| { &m.team_name },
            |m: &mut AvatarTeam| { &mut m.team_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AvatarTeam>(
            "AvatarTeam",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AvatarTeam {
    const NAME: &'static str = "AvatarTeam";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                82 => {
                    is.read_repeated_packed_uint64_into(&mut self.avatar_guid_list)?;
                },
                80 => {
                    self.avatar_guid_list.push(is.read_uint64()?);
                },
                34 => {
                    self.team_name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::vec_packed_uint64_size(10, &self.avatar_guid_list);
        if !self.team_name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.team_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_repeated_packed_uint64(10, &self.avatar_guid_list)?;
        if !self.team_name.is_empty() {
            os.write_string(4, &self.team_name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AvatarTeam {
        AvatarTeam::new()
    }

    fn clear(&mut self) {
        self.avatar_guid_list.clear();
        self.team_name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AvatarTeam {
        static instance: AvatarTeam = AvatarTeam {
            avatar_guid_list: ::std::vec::Vec::new(),
            team_name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AvatarTeam {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AvatarTeam").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AvatarTeam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AvatarTeam {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Mualani.Guide.Property)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Property {
    // message fields
    // @@protoc_insertion_point(field:Mualani.Guide.Property.id)
    pub id: u32,
    // @@protoc_insertion_point(field:Mualani.Guide.Property.val)
    pub val: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:Mualani.Guide.Property.fval)
    pub fval: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:Mualani.Guide.Property.ival)
    pub ival: i64,
    // special fields
    // @@protoc_insertion_point(special_field:Mualani.Guide.Property.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Property {
    fn default() -> &'a Property {
        <Property as ::protobuf::Message>::default_instance()
    }
}

impl Property {
    pub fn new() -> Property {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Property| { &m.id },
            |m: &mut Property| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "val",
            |m: &Property| { &m.val },
            |m: &mut Property| { &mut m.val },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fval",
            |m: &Property| { &m.fval },
            |m: &mut Property| { &mut m.fval },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ival",
            |m: &Property| { &m.ival },
            |m: &mut Property| { &mut m.ival },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Property>(
            "Property",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Property {
    const NAME: &'static str = "Property";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint32()?;
                },
                16 => {
                    self.val = ::std::option::Option::Some(is.read_int64()?);
                },
                29 => {
                    self.fval = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.ival = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.id);
        }
        if let Some(v) = self.val {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.fval {
            my_size += 1 + 4;
        }
        if self.ival != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.ival);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if let Some(v) = self.val {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.fval {
            os.write_float(3, v)?;
        }
        if self.ival != 0 {
            os.write_int64(4, self.ival)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Property {
        Property::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.val = ::std::option::Option::None;
        self.fval = ::std::option::Option::None;
        self.ival = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Property {
        static instance: Property = Property {
            id: 0,
            val: ::std::option::Option::None,
            fval: ::std::option::Option::None,
            ival: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Property {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Property").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Property {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Property {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Mualani.Guide.FetterData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FetterData {
    // message fields
    // @@protoc_insertion_point(field:Mualani.Guide.FetterData.fetter_id)
    pub fetter_id: u32,
    // @@protoc_insertion_point(field:Mualani.Guide.FetterData.fetter_state)
    pub fetter_state: u32,
    // @@protoc_insertion_point(field:Mualani.Guide.FetterData.cond_index_list)
    pub cond_index_list: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:Mualani.Guide.FetterData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FetterData {
    fn default() -> &'a FetterData {
        <FetterData as ::protobuf::Message>::default_instance()
    }
}

impl FetterData {
    pub fn new() -> FetterData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fetter_id",
            |m: &FetterData| { &m.fetter_id },
            |m: &mut FetterData| { &mut m.fetter_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fetter_state",
            |m: &FetterData| { &m.fetter_state },
            |m: &mut FetterData| { &mut m.fetter_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "cond_index_list",
            |m: &FetterData| { &m.cond_index_list },
            |m: &mut FetterData| { &mut m.cond_index_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FetterData>(
            "FetterData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FetterData {
    const NAME: &'static str = "FetterData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fetter_id = is.read_uint32()?;
                },
                16 => {
                    self.fetter_state = is.read_uint32()?;
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.cond_index_list)?;
                },
                24 => {
                    self.cond_index_list.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fetter_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.fetter_id);
        }
        if self.fetter_state != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.fetter_state);
        }
        my_size += ::protobuf::rt::vec_packed_uint32_size(3, &self.cond_index_list);
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fetter_id != 0 {
            os.write_uint32(1, self.fetter_id)?;
        }
        if self.fetter_state != 0 {
            os.write_uint32(2, self.fetter_state)?;
        }
        os.write_repeated_packed_uint32(3, &self.cond_index_list)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FetterData {
        FetterData::new()
    }

    fn clear(&mut self) {
        self.fetter_id = 0;
        self.fetter_state = 0;
        self.cond_index_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FetterData {
        static instance: FetterData = FetterData {
            fetter_id: 0,
            fetter_state: 0,
            cond_index_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FetterData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FetterData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FetterData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FetterData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Mualani.Guide.FetterInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FetterInfo {
    // message fields
    // @@protoc_insertion_point(field:Mualani.Guide.FetterInfo.level)
    pub level: u32,
    // @@protoc_insertion_point(field:Mualani.Guide.FetterInfo.exp)
    pub exp: u32,
    // @@protoc_insertion_point(field:Mualani.Guide.FetterInfo.open_id_list)
    pub open_id_list: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:Mualani.Guide.FetterInfo.finish_id_list)
    pub finish_id_list: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:Mualani.Guide.FetterInfo.rewarded_fetter_level_list)
    pub rewarded_fetter_level_list: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:Mualani.Guide.FetterInfo.data)
    pub data: ::std::vec::Vec<FetterData>,
    // special fields
    // @@protoc_insertion_point(special_field:Mualani.Guide.FetterInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FetterInfo {
    fn default() -> &'a FetterInfo {
        <FetterInfo as ::protobuf::Message>::default_instance()
    }
}

impl FetterInfo {
    pub fn new() -> FetterInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "level",
            |m: &FetterInfo| { &m.level },
            |m: &mut FetterInfo| { &mut m.level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exp",
            |m: &FetterInfo| { &m.exp },
            |m: &mut FetterInfo| { &mut m.exp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "open_id_list",
            |m: &FetterInfo| { &m.open_id_list },
            |m: &mut FetterInfo| { &mut m.open_id_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "finish_id_list",
            |m: &FetterInfo| { &m.finish_id_list },
            |m: &mut FetterInfo| { &mut m.finish_id_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rewarded_fetter_level_list",
            |m: &FetterInfo| { &m.rewarded_fetter_level_list },
            |m: &mut FetterInfo| { &mut m.rewarded_fetter_level_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data",
            |m: &FetterInfo| { &m.data },
            |m: &mut FetterInfo| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FetterInfo>(
            "FetterInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FetterInfo {
    const NAME: &'static str = "FetterInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.level = is.read_uint32()?;
                },
                8 => {
                    self.exp = is.read_uint32()?;
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.open_id_list)?;
                },
                24 => {
                    self.open_id_list.push(is.read_uint32()?);
                },
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.finish_id_list)?;
                },
                32 => {
                    self.finish_id_list.push(is.read_uint32()?);
                },
                42 => {
                    is.read_repeated_packed_uint32_into(&mut self.rewarded_fetter_level_list)?;
                },
                40 => {
                    self.rewarded_fetter_level_list.push(is.read_uint32()?);
                },
                50 => {
                    self.data.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.level != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.level);
        }
        if self.exp != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.exp);
        }
        my_size += ::protobuf::rt::vec_packed_uint32_size(3, &self.open_id_list);
        my_size += ::protobuf::rt::vec_packed_uint32_size(4, &self.finish_id_list);
        my_size += ::protobuf::rt::vec_packed_uint32_size(5, &self.rewarded_fetter_level_list);
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.level != 0 {
            os.write_uint32(2, self.level)?;
        }
        if self.exp != 0 {
            os.write_uint32(1, self.exp)?;
        }
        os.write_repeated_packed_uint32(3, &self.open_id_list)?;
        os.write_repeated_packed_uint32(4, &self.finish_id_list)?;
        os.write_repeated_packed_uint32(5, &self.rewarded_fetter_level_list)?;
        for v in &self.data {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FetterInfo {
        FetterInfo::new()
    }

    fn clear(&mut self) {
        self.level = 0;
        self.exp = 0;
        self.open_id_list.clear();
        self.finish_id_list.clear();
        self.rewarded_fetter_level_list.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FetterInfo {
        static instance: FetterInfo = FetterInfo {
            level: 0,
            exp: 0,
            open_id_list: ::std::vec::Vec::new(),
            finish_id_list: ::std::vec::Vec::new(),
            rewarded_fetter_level_list: ::std::vec::Vec::new(),
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FetterInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FetterInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FetterInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FetterInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Mualani.Guide.AvatarInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AvatarInfo {
    // message fields
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarInfo.avatar_id)
    pub avatar_id: u32,
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarInfo.guid)
    pub guid: u64,
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarInfo.props)
    pub props: ::std::collections::HashMap<u32, Property>,
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarInfo.life_state)
    pub life_state: u32,
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarInfo.equip_guid_list)
    pub equip_guid_list: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarInfo.talent_id_list)
    pub talent_id_list: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarInfo.fight_prop_map)
    pub fight_prop_map: ::std::collections::HashMap<u32, f32>,
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarInfo.fetter)
    pub fetter: ::protobuf::MessageField<FetterInfo>,
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarInfo.skill_depot_id)
    pub skill_depot_id: u32,
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarInfo.core_proud_skill_level)
    pub core_proud_skill_level: u32,
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarInfo.inherent_proud_skill_list)
    pub inherent_proud_skill_list: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarInfo.skill_level_map)
    pub skill_level_map: ::std::collections::HashMap<u32, u32>,
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarInfo.proud_skill_extra_level_map)
    pub proud_skill_extra_level_map: ::std::collections::HashMap<u32, u32>,
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarInfo.is_focus)
    pub is_focus: bool,
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarInfo.avatar_type)
    pub avatar_type: u32,
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarInfo.team_resonance_list)
    pub team_resonance_list: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarInfo.wearing_flycloak_id)
    pub wearing_flycloak_id: u32,
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarInfo.born_time)
    pub born_time: u32,
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarInfo.pending_promote_reward_list)
    pub pending_promote_reward_list: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarInfo.costume_id)
    pub costume_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:Mualani.Guide.AvatarInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AvatarInfo {
    fn default() -> &'a AvatarInfo {
        <AvatarInfo as ::protobuf::Message>::default_instance()
    }
}

impl AvatarInfo {
    pub fn new() -> AvatarInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(20);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "avatar_id",
            |m: &AvatarInfo| { &m.avatar_id },
            |m: &mut AvatarInfo| { &mut m.avatar_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "guid",
            |m: &AvatarInfo| { &m.guid },
            |m: &mut AvatarInfo| { &mut m.guid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "props",
            |m: &AvatarInfo| { &m.props },
            |m: &mut AvatarInfo| { &mut m.props },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "life_state",
            |m: &AvatarInfo| { &m.life_state },
            |m: &mut AvatarInfo| { &mut m.life_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "equip_guid_list",
            |m: &AvatarInfo| { &m.equip_guid_list },
            |m: &mut AvatarInfo| { &mut m.equip_guid_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "talent_id_list",
            |m: &AvatarInfo| { &m.talent_id_list },
            |m: &mut AvatarInfo| { &mut m.talent_id_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "fight_prop_map",
            |m: &AvatarInfo| { &m.fight_prop_map },
            |m: &mut AvatarInfo| { &mut m.fight_prop_map },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FetterInfo>(
            "fetter",
            |m: &AvatarInfo| { &m.fetter },
            |m: &mut AvatarInfo| { &mut m.fetter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "skill_depot_id",
            |m: &AvatarInfo| { &m.skill_depot_id },
            |m: &mut AvatarInfo| { &mut m.skill_depot_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "core_proud_skill_level",
            |m: &AvatarInfo| { &m.core_proud_skill_level },
            |m: &mut AvatarInfo| { &mut m.core_proud_skill_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inherent_proud_skill_list",
            |m: &AvatarInfo| { &m.inherent_proud_skill_list },
            |m: &mut AvatarInfo| { &mut m.inherent_proud_skill_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "skill_level_map",
            |m: &AvatarInfo| { &m.skill_level_map },
            |m: &mut AvatarInfo| { &mut m.skill_level_map },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "proud_skill_extra_level_map",
            |m: &AvatarInfo| { &m.proud_skill_extra_level_map },
            |m: &mut AvatarInfo| { &mut m.proud_skill_extra_level_map },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_focus",
            |m: &AvatarInfo| { &m.is_focus },
            |m: &mut AvatarInfo| { &mut m.is_focus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "avatar_type",
            |m: &AvatarInfo| { &m.avatar_type },
            |m: &mut AvatarInfo| { &mut m.avatar_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "team_resonance_list",
            |m: &AvatarInfo| { &m.team_resonance_list },
            |m: &mut AvatarInfo| { &mut m.team_resonance_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "wearing_flycloak_id",
            |m: &AvatarInfo| { &m.wearing_flycloak_id },
            |m: &mut AvatarInfo| { &mut m.wearing_flycloak_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "born_time",
            |m: &AvatarInfo| { &m.born_time },
            |m: &mut AvatarInfo| { &mut m.born_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pending_promote_reward_list",
            |m: &AvatarInfo| { &m.pending_promote_reward_list },
            |m: &mut AvatarInfo| { &mut m.pending_promote_reward_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "costume_id",
            |m: &AvatarInfo| { &m.costume_id },
            |m: &mut AvatarInfo| { &mut m.costume_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AvatarInfo>(
            "AvatarInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AvatarInfo {
    const NAME: &'static str = "AvatarInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.avatar_id = is.read_uint32()?;
                },
                16 => {
                    self.guid = is.read_uint64()?;
                },
                26 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => key = is.read_uint32()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.props.insert(key, value);
                },
                32 => {
                    self.life_state = is.read_uint32()?;
                },
                42 => {
                    is.read_repeated_packed_uint64_into(&mut self.equip_guid_list)?;
                },
                40 => {
                    self.equip_guid_list.push(is.read_uint64()?);
                },
                50 => {
                    is.read_repeated_packed_uint32_into(&mut self.talent_id_list)?;
                },
                48 => {
                    self.talent_id_list.push(is.read_uint32()?);
                },
                58 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => key = is.read_uint32()?,
                            21 => value = is.read_float()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.fight_prop_map.insert(key, value);
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fetter)?;
                },
                88 => {
                    self.skill_depot_id = is.read_uint32()?;
                },
                104 => {
                    self.core_proud_skill_level = is.read_uint32()?;
                },
                114 => {
                    is.read_repeated_packed_uint32_into(&mut self.inherent_proud_skill_list)?;
                },
                112 => {
                    self.inherent_proud_skill_list.push(is.read_uint32()?);
                },
                122 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => key = is.read_uint32()?,
                            16 => value = is.read_uint32()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.skill_level_map.insert(key, value);
                },
                138 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => key = is.read_uint32()?,
                            16 => value = is.read_uint32()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.proud_skill_extra_level_map.insert(key, value);
                },
                144 => {
                    self.is_focus = is.read_bool()?;
                },
                152 => {
                    self.avatar_type = is.read_uint32()?;
                },
                162 => {
                    is.read_repeated_packed_uint32_into(&mut self.team_resonance_list)?;
                },
                160 => {
                    self.team_resonance_list.push(is.read_uint32()?);
                },
                168 => {
                    self.wearing_flycloak_id = is.read_uint32()?;
                },
                184 => {
                    self.born_time = is.read_uint32()?;
                },
                194 => {
                    is.read_repeated_packed_uint32_into(&mut self.pending_promote_reward_list)?;
                },
                192 => {
                    self.pending_promote_reward_list.push(is.read_uint32()?);
                },
                200 => {
                    self.costume_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.avatar_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.avatar_id);
        }
        if self.guid != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.guid);
        }
        for (k, v) in &self.props {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::uint32_size(1, *k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if self.life_state != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.life_state);
        }
        my_size += ::protobuf::rt::vec_packed_uint64_size(5, &self.equip_guid_list);
        my_size += ::protobuf::rt::vec_packed_uint32_size(6, &self.talent_id_list);
        for (k, v) in &self.fight_prop_map {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::uint32_size(1, *k);
            entry_size += 1 + 4;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.fetter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.skill_depot_id != 0 {
            my_size += ::protobuf::rt::uint32_size(11, self.skill_depot_id);
        }
        if self.core_proud_skill_level != 0 {
            my_size += ::protobuf::rt::uint32_size(13, self.core_proud_skill_level);
        }
        my_size += ::protobuf::rt::vec_packed_uint32_size(14, &self.inherent_proud_skill_list);
        for (k, v) in &self.skill_level_map {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::uint32_size(1, *k);
            entry_size += ::protobuf::rt::uint32_size(2, *v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.proud_skill_extra_level_map {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::uint32_size(1, *k);
            entry_size += ::protobuf::rt::uint32_size(2, *v);
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if self.is_focus != false {
            my_size += 2 + 1;
        }
        if self.avatar_type != 0 {
            my_size += ::protobuf::rt::uint32_size(19, self.avatar_type);
        }
        my_size += ::protobuf::rt::vec_packed_uint32_size(20, &self.team_resonance_list);
        if self.wearing_flycloak_id != 0 {
            my_size += ::protobuf::rt::uint32_size(21, self.wearing_flycloak_id);
        }
        if self.born_time != 0 {
            my_size += ::protobuf::rt::uint32_size(23, self.born_time);
        }
        my_size += ::protobuf::rt::vec_packed_uint32_size(24, &self.pending_promote_reward_list);
        if self.costume_id != 0 {
            my_size += ::protobuf::rt::uint32_size(25, self.costume_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.avatar_id != 0 {
            os.write_uint32(1, self.avatar_id)?;
        }
        if self.guid != 0 {
            os.write_uint64(2, self.guid)?;
        }
        for (k, v) in &self.props {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::uint32_size(1, *k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(26)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_uint32(1, *k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if self.life_state != 0 {
            os.write_uint32(4, self.life_state)?;
        }
        os.write_repeated_packed_uint64(5, &self.equip_guid_list)?;
        os.write_repeated_packed_uint32(6, &self.talent_id_list)?;
        for (k, v) in &self.fight_prop_map {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::uint32_size(1, *k);
            entry_size += 1 + 4;
            os.write_raw_varint32(58)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_uint32(1, *k)?;
            os.write_float(2, *v)?;
        };
        if let Some(v) = self.fetter.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if self.skill_depot_id != 0 {
            os.write_uint32(11, self.skill_depot_id)?;
        }
        if self.core_proud_skill_level != 0 {
            os.write_uint32(13, self.core_proud_skill_level)?;
        }
        os.write_repeated_packed_uint32(14, &self.inherent_proud_skill_list)?;
        for (k, v) in &self.skill_level_map {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::uint32_size(1, *k);
            entry_size += ::protobuf::rt::uint32_size(2, *v);
            os.write_raw_varint32(122)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_uint32(1, *k)?;
            os.write_uint32(2, *v)?;
        };
        for (k, v) in &self.proud_skill_extra_level_map {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::uint32_size(1, *k);
            entry_size += ::protobuf::rt::uint32_size(2, *v);
            os.write_raw_varint32(138)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_uint32(1, *k)?;
            os.write_uint32(2, *v)?;
        };
        if self.is_focus != false {
            os.write_bool(18, self.is_focus)?;
        }
        if self.avatar_type != 0 {
            os.write_uint32(19, self.avatar_type)?;
        }
        os.write_repeated_packed_uint32(20, &self.team_resonance_list)?;
        if self.wearing_flycloak_id != 0 {
            os.write_uint32(21, self.wearing_flycloak_id)?;
        }
        if self.born_time != 0 {
            os.write_uint32(23, self.born_time)?;
        }
        os.write_repeated_packed_uint32(24, &self.pending_promote_reward_list)?;
        if self.costume_id != 0 {
            os.write_uint32(25, self.costume_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AvatarInfo {
        AvatarInfo::new()
    }

    fn clear(&mut self) {
        self.avatar_id = 0;
        self.guid = 0;
        self.props.clear();
        self.life_state = 0;
        self.equip_guid_list.clear();
        self.talent_id_list.clear();
        self.fight_prop_map.clear();
        self.fetter.clear();
        self.skill_depot_id = 0;
        self.core_proud_skill_level = 0;
        self.inherent_proud_skill_list.clear();
        self.skill_level_map.clear();
        self.proud_skill_extra_level_map.clear();
        self.is_focus = false;
        self.avatar_type = 0;
        self.team_resonance_list.clear();
        self.wearing_flycloak_id = 0;
        self.born_time = 0;
        self.pending_promote_reward_list.clear();
        self.costume_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AvatarInfo {
        static instance: ::protobuf::rt::Lazy<AvatarInfo> = ::protobuf::rt::Lazy::new();
        instance.get(AvatarInfo::new)
    }
}

impl ::protobuf::MessageFull for AvatarInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AvatarInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AvatarInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AvatarInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Mualani.Guide.AvatarNotify)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AvatarNotify {
    // message fields
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarNotify.flycloaks)
    pub flycloaks: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarNotify.choosen_guid)
    pub choosen_guid: u64,
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarNotify.costumes)
    pub costumes: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarNotify.team_order)
    pub team_order: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarNotify.avatar_team_map)
    pub avatar_team_map: ::std::collections::HashMap<u32, AvatarTeam>,
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarNotify.cur_avatar_team_id)
    pub cur_avatar_team_id: u32,
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarNotify.temp_avatar_guid_list)
    pub temp_avatar_guid_list: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarNotify.renames)
    pub renames: ::std::vec::Vec<AvatarRenameInfo>,
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarNotify.avatars)
    pub avatars: ::std::vec::Vec<AvatarInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:Mualani.Guide.AvatarNotify.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AvatarNotify {
    fn default() -> &'a AvatarNotify {
        <AvatarNotify as ::protobuf::Message>::default_instance()
    }
}

impl AvatarNotify {
    pub fn new() -> AvatarNotify {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "flycloaks",
            |m: &AvatarNotify| { &m.flycloaks },
            |m: &mut AvatarNotify| { &mut m.flycloaks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "choosen_guid",
            |m: &AvatarNotify| { &m.choosen_guid },
            |m: &mut AvatarNotify| { &mut m.choosen_guid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "costumes",
            |m: &AvatarNotify| { &m.costumes },
            |m: &mut AvatarNotify| { &mut m.costumes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "team_order",
            |m: &AvatarNotify| { &m.team_order },
            |m: &mut AvatarNotify| { &mut m.team_order },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "avatar_team_map",
            |m: &AvatarNotify| { &m.avatar_team_map },
            |m: &mut AvatarNotify| { &mut m.avatar_team_map },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cur_avatar_team_id",
            |m: &AvatarNotify| { &m.cur_avatar_team_id },
            |m: &mut AvatarNotify| { &mut m.cur_avatar_team_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "temp_avatar_guid_list",
            |m: &AvatarNotify| { &m.temp_avatar_guid_list },
            |m: &mut AvatarNotify| { &mut m.temp_avatar_guid_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "renames",
            |m: &AvatarNotify| { &m.renames },
            |m: &mut AvatarNotify| { &mut m.renames },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "avatars",
            |m: &AvatarNotify| { &m.avatars },
            |m: &mut AvatarNotify| { &mut m.avatars },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AvatarNotify>(
            "AvatarNotify",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AvatarNotify {
    const NAME: &'static str = "AvatarNotify";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.flycloaks)?;
                },
                32 => {
                    self.flycloaks.push(is.read_uint32()?);
                },
                8 => {
                    self.choosen_guid = is.read_uint64()?;
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.costumes)?;
                },
                16 => {
                    self.costumes.push(is.read_uint32()?);
                },
                106 => {
                    is.read_repeated_packed_uint32_into(&mut self.team_order)?;
                },
                104 => {
                    self.team_order.push(is.read_uint32()?);
                },
                74 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => key = is.read_uint32()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.avatar_team_map.insert(key, value);
                },
                48 => {
                    self.cur_avatar_team_id = is.read_uint32()?;
                },
                786 => {
                    is.read_repeated_packed_uint64_into(&mut self.temp_avatar_guid_list)?;
                },
                784 => {
                    self.temp_avatar_guid_list.push(is.read_uint64()?);
                },
                122 => {
                    self.renames.push(is.read_message()?);
                },
                58 => {
                    self.avatars.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::vec_packed_uint32_size(4, &self.flycloaks);
        if self.choosen_guid != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.choosen_guid);
        }
        my_size += ::protobuf::rt::vec_packed_uint32_size(2, &self.costumes);
        my_size += ::protobuf::rt::vec_packed_uint32_size(13, &self.team_order);
        for (k, v) in &self.avatar_team_map {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::uint32_size(1, *k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if self.cur_avatar_team_id != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.cur_avatar_team_id);
        }
        my_size += ::protobuf::rt::vec_packed_uint64_size(98, &self.temp_avatar_guid_list);
        for value in &self.renames {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.avatars {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_repeated_packed_uint32(4, &self.flycloaks)?;
        if self.choosen_guid != 0 {
            os.write_uint64(1, self.choosen_guid)?;
        }
        os.write_repeated_packed_uint32(2, &self.costumes)?;
        os.write_repeated_packed_uint32(13, &self.team_order)?;
        for (k, v) in &self.avatar_team_map {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::uint32_size(1, *k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(74)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_uint32(1, *k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if self.cur_avatar_team_id != 0 {
            os.write_uint32(6, self.cur_avatar_team_id)?;
        }
        os.write_repeated_packed_uint64(98, &self.temp_avatar_guid_list)?;
        for v in &self.renames {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        };
        for v in &self.avatars {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AvatarNotify {
        AvatarNotify::new()
    }

    fn clear(&mut self) {
        self.flycloaks.clear();
        self.choosen_guid = 0;
        self.costumes.clear();
        self.team_order.clear();
        self.avatar_team_map.clear();
        self.cur_avatar_team_id = 0;
        self.temp_avatar_guid_list.clear();
        self.renames.clear();
        self.avatars.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AvatarNotify {
        static instance: ::protobuf::rt::Lazy<AvatarNotify> = ::protobuf::rt::Lazy::new();
        instance.get(AvatarNotify::new)
    }
}

impl ::protobuf::MessageFull for AvatarNotify {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AvatarNotify").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AvatarNotify {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AvatarNotify {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Mualani.Guide.AvatarAddedNotify)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AvatarAddedNotify {
    // message fields
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarAddedNotify.avatar)
    pub avatar: ::protobuf::MessageField<AvatarInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:Mualani.Guide.AvatarAddedNotify.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AvatarAddedNotify {
    fn default() -> &'a AvatarAddedNotify {
        <AvatarAddedNotify as ::protobuf::Message>::default_instance()
    }
}

impl AvatarAddedNotify {
    pub fn new() -> AvatarAddedNotify {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AvatarInfo>(
            "avatar",
            |m: &AvatarAddedNotify| { &m.avatar },
            |m: &mut AvatarAddedNotify| { &mut m.avatar },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AvatarAddedNotify>(
            "AvatarAddedNotify",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AvatarAddedNotify {
    const NAME: &'static str = "AvatarAddedNotify";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.avatar)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.avatar.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.avatar.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AvatarAddedNotify {
        AvatarAddedNotify::new()
    }

    fn clear(&mut self) {
        self.avatar.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AvatarAddedNotify {
        static instance: AvatarAddedNotify = AvatarAddedNotify {
            avatar: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AvatarAddedNotify {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AvatarAddedNotify").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AvatarAddedNotify {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AvatarAddedNotify {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Mualani.Guide.AvatarSkillUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AvatarSkillUpdate {
    // message fields
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarSkillUpdate.skill_depot)
    pub skill_depot: u32,
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarSkillUpdate.guid)
    pub guid: u64,
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarSkillUpdate.cur_level)
    pub cur_level: u32,
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarSkillUpdate.avatar_skill_id)
    pub avatar_skill_id: u32,
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarSkillUpdate.old_level)
    pub old_level: u32,
    // special fields
    // @@protoc_insertion_point(special_field:Mualani.Guide.AvatarSkillUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AvatarSkillUpdate {
    fn default() -> &'a AvatarSkillUpdate {
        <AvatarSkillUpdate as ::protobuf::Message>::default_instance()
    }
}

impl AvatarSkillUpdate {
    pub fn new() -> AvatarSkillUpdate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "skill_depot",
            |m: &AvatarSkillUpdate| { &m.skill_depot },
            |m: &mut AvatarSkillUpdate| { &mut m.skill_depot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "guid",
            |m: &AvatarSkillUpdate| { &m.guid },
            |m: &mut AvatarSkillUpdate| { &mut m.guid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cur_level",
            |m: &AvatarSkillUpdate| { &m.cur_level },
            |m: &mut AvatarSkillUpdate| { &mut m.cur_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "avatar_skill_id",
            |m: &AvatarSkillUpdate| { &m.avatar_skill_id },
            |m: &mut AvatarSkillUpdate| { &mut m.avatar_skill_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "old_level",
            |m: &AvatarSkillUpdate| { &m.old_level },
            |m: &mut AvatarSkillUpdate| { &mut m.old_level },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AvatarSkillUpdate>(
            "AvatarSkillUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AvatarSkillUpdate {
    const NAME: &'static str = "AvatarSkillUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                48 => {
                    self.skill_depot = is.read_uint32()?;
                },
                80 => {
                    self.guid = is.read_uint64()?;
                },
                24 => {
                    self.cur_level = is.read_uint32()?;
                },
                104 => {
                    self.avatar_skill_id = is.read_uint32()?;
                },
                16 => {
                    self.old_level = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.skill_depot != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.skill_depot);
        }
        if self.guid != 0 {
            my_size += ::protobuf::rt::uint64_size(10, self.guid);
        }
        if self.cur_level != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.cur_level);
        }
        if self.avatar_skill_id != 0 {
            my_size += ::protobuf::rt::uint32_size(13, self.avatar_skill_id);
        }
        if self.old_level != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.old_level);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.skill_depot != 0 {
            os.write_uint32(6, self.skill_depot)?;
        }
        if self.guid != 0 {
            os.write_uint64(10, self.guid)?;
        }
        if self.cur_level != 0 {
            os.write_uint32(3, self.cur_level)?;
        }
        if self.avatar_skill_id != 0 {
            os.write_uint32(13, self.avatar_skill_id)?;
        }
        if self.old_level != 0 {
            os.write_uint32(2, self.old_level)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AvatarSkillUpdate {
        AvatarSkillUpdate::new()
    }

    fn clear(&mut self) {
        self.skill_depot = 0;
        self.guid = 0;
        self.cur_level = 0;
        self.avatar_skill_id = 0;
        self.old_level = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AvatarSkillUpdate {
        static instance: AvatarSkillUpdate = AvatarSkillUpdate {
            skill_depot: 0,
            guid: 0,
            cur_level: 0,
            avatar_skill_id: 0,
            old_level: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AvatarSkillUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AvatarSkillUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AvatarSkillUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AvatarSkillUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Mualani.Guide.AvatarPropertyUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AvatarPropertyUpdate {
    // message fields
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarPropertyUpdate.guid)
    pub guid: u64,
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarPropertyUpdate.props)
    pub props: ::std::collections::HashMap<u32, i64>,
    // special fields
    // @@protoc_insertion_point(special_field:Mualani.Guide.AvatarPropertyUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AvatarPropertyUpdate {
    fn default() -> &'a AvatarPropertyUpdate {
        <AvatarPropertyUpdate as ::protobuf::Message>::default_instance()
    }
}

impl AvatarPropertyUpdate {
    pub fn new() -> AvatarPropertyUpdate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "guid",
            |m: &AvatarPropertyUpdate| { &m.guid },
            |m: &mut AvatarPropertyUpdate| { &mut m.guid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "props",
            |m: &AvatarPropertyUpdate| { &m.props },
            |m: &mut AvatarPropertyUpdate| { &mut m.props },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AvatarPropertyUpdate>(
            "AvatarPropertyUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AvatarPropertyUpdate {
    const NAME: &'static str = "AvatarPropertyUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                48 => {
                    self.guid = is.read_uint64()?;
                },
                42 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => key = is.read_uint32()?,
                            16 => value = is.read_int64()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.props.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.guid != 0 {
            my_size += ::protobuf::rt::uint64_size(6, self.guid);
        }
        for (k, v) in &self.props {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::uint32_size(1, *k);
            entry_size += ::protobuf::rt::int64_size(2, *v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.guid != 0 {
            os.write_uint64(6, self.guid)?;
        }
        for (k, v) in &self.props {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::uint32_size(1, *k);
            entry_size += ::protobuf::rt::int64_size(2, *v);
            os.write_raw_varint32(42)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_uint32(1, *k)?;
            os.write_int64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AvatarPropertyUpdate {
        AvatarPropertyUpdate::new()
    }

    fn clear(&mut self) {
        self.guid = 0;
        self.props.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AvatarPropertyUpdate {
        static instance: ::protobuf::rt::Lazy<AvatarPropertyUpdate> = ::protobuf::rt::Lazy::new();
        instance.get(AvatarPropertyUpdate::new)
    }
}

impl ::protobuf::MessageFull for AvatarPropertyUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AvatarPropertyUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AvatarPropertyUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AvatarPropertyUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Mualani.Guide.AvatarFightPropUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AvatarFightPropUpdate {
    // message fields
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarFightPropUpdate.guid)
    pub guid: u64,
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarFightPropUpdate.props)
    pub props: ::std::collections::HashMap<u32, f32>,
    // special fields
    // @@protoc_insertion_point(special_field:Mualani.Guide.AvatarFightPropUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AvatarFightPropUpdate {
    fn default() -> &'a AvatarFightPropUpdate {
        <AvatarFightPropUpdate as ::protobuf::Message>::default_instance()
    }
}

impl AvatarFightPropUpdate {
    pub fn new() -> AvatarFightPropUpdate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "guid",
            |m: &AvatarFightPropUpdate| { &m.guid },
            |m: &mut AvatarFightPropUpdate| { &mut m.guid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "props",
            |m: &AvatarFightPropUpdate| { &m.props },
            |m: &mut AvatarFightPropUpdate| { &mut m.props },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AvatarFightPropUpdate>(
            "AvatarFightPropUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AvatarFightPropUpdate {
    const NAME: &'static str = "AvatarFightPropUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                24 => {
                    self.guid = is.read_uint64()?;
                },
                98 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => key = is.read_uint32()?,
                            21 => value = is.read_float()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.props.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.guid != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.guid);
        }
        for (k, v) in &self.props {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::uint32_size(1, *k);
            entry_size += 1 + 4;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.guid != 0 {
            os.write_uint64(3, self.guid)?;
        }
        for (k, v) in &self.props {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::uint32_size(1, *k);
            entry_size += 1 + 4;
            os.write_raw_varint32(98)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_uint32(1, *k)?;
            os.write_float(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AvatarFightPropUpdate {
        AvatarFightPropUpdate::new()
    }

    fn clear(&mut self) {
        self.guid = 0;
        self.props.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AvatarFightPropUpdate {
        static instance: ::protobuf::rt::Lazy<AvatarFightPropUpdate> = ::protobuf::rt::Lazy::new();
        instance.get(AvatarFightPropUpdate::new)
    }
}

impl ::protobuf::MessageFull for AvatarFightPropUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AvatarFightPropUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AvatarFightPropUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AvatarFightPropUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Mualani.Guide.EntityFightPropUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EntityFightPropUpdate {
    // message fields
    // @@protoc_insertion_point(field:Mualani.Guide.EntityFightPropUpdate.eid)
    pub eid: u64,
    // @@protoc_insertion_point(field:Mualani.Guide.EntityFightPropUpdate.props)
    pub props: ::std::collections::HashMap<u32, f32>,
    // special fields
    // @@protoc_insertion_point(special_field:Mualani.Guide.EntityFightPropUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EntityFightPropUpdate {
    fn default() -> &'a EntityFightPropUpdate {
        <EntityFightPropUpdate as ::protobuf::Message>::default_instance()
    }
}

impl EntityFightPropUpdate {
    pub fn new() -> EntityFightPropUpdate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "eid",
            |m: &EntityFightPropUpdate| { &m.eid },
            |m: &mut EntityFightPropUpdate| { &mut m.eid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "props",
            |m: &EntityFightPropUpdate| { &m.props },
            |m: &mut EntityFightPropUpdate| { &mut m.props },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EntityFightPropUpdate>(
            "EntityFightPropUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EntityFightPropUpdate {
    const NAME: &'static str = "EntityFightPropUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                112 => {
                    self.eid = is.read_uint64()?;
                },
                106 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => key = is.read_uint32()?,
                            21 => value = is.read_float()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.props.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.eid != 0 {
            my_size += ::protobuf::rt::uint64_size(14, self.eid);
        }
        for (k, v) in &self.props {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::uint32_size(1, *k);
            entry_size += 1 + 4;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.eid != 0 {
            os.write_uint64(14, self.eid)?;
        }
        for (k, v) in &self.props {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::uint32_size(1, *k);
            entry_size += 1 + 4;
            os.write_raw_varint32(106)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_uint32(1, *k)?;
            os.write_float(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EntityFightPropUpdate {
        EntityFightPropUpdate::new()
    }

    fn clear(&mut self) {
        self.eid = 0;
        self.props.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EntityFightPropUpdate {
        static instance: ::protobuf::rt::Lazy<EntityFightPropUpdate> = ::protobuf::rt::Lazy::new();
        instance.get(EntityFightPropUpdate::new)
    }
}

impl ::protobuf::MessageFull for EntityFightPropUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EntityFightPropUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EntityFightPropUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EntityFightPropUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Mualani.Guide.TeamSwapNotify)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TeamSwapNotify {
    // message fields
    // @@protoc_insertion_point(field:Mualani.Guide.TeamSwapNotify.curteam_id)
    pub curteam_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:Mualani.Guide.TeamSwapNotify.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TeamSwapNotify {
    fn default() -> &'a TeamSwapNotify {
        <TeamSwapNotify as ::protobuf::Message>::default_instance()
    }
}

impl TeamSwapNotify {
    pub fn new() -> TeamSwapNotify {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "curteam_id",
            |m: &TeamSwapNotify| { &m.curteam_id },
            |m: &mut TeamSwapNotify| { &mut m.curteam_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TeamSwapNotify>(
            "TeamSwapNotify",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TeamSwapNotify {
    const NAME: &'static str = "TeamSwapNotify";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                64 => {
                    self.curteam_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.curteam_id != 0 {
            my_size += ::protobuf::rt::uint32_size(8, self.curteam_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.curteam_id != 0 {
            os.write_uint32(8, self.curteam_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TeamSwapNotify {
        TeamSwapNotify::new()
    }

    fn clear(&mut self) {
        self.curteam_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TeamSwapNotify {
        static instance: TeamSwapNotify = TeamSwapNotify {
            curteam_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TeamSwapNotify {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TeamSwapNotify").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TeamSwapNotify {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TeamSwapNotify {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Mualani.Guide.AvatarSwapNotify)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AvatarSwapNotify {
    // message fields
    // @@protoc_insertion_point(field:Mualani.Guide.AvatarSwapNotify.guid)
    pub guid: u64,
    // special fields
    // @@protoc_insertion_point(special_field:Mualani.Guide.AvatarSwapNotify.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AvatarSwapNotify {
    fn default() -> &'a AvatarSwapNotify {
        <AvatarSwapNotify as ::protobuf::Message>::default_instance()
    }
}

impl AvatarSwapNotify {
    pub fn new() -> AvatarSwapNotify {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "guid",
            |m: &AvatarSwapNotify| { &m.guid },
            |m: &mut AvatarSwapNotify| { &mut m.guid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AvatarSwapNotify>(
            "AvatarSwapNotify",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AvatarSwapNotify {
    const NAME: &'static str = "AvatarSwapNotify";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                112 => {
                    self.guid = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.guid != 0 {
            my_size += ::protobuf::rt::uint64_size(14, self.guid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.guid != 0 {
            os.write_uint64(14, self.guid)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AvatarSwapNotify {
        AvatarSwapNotify::new()
    }

    fn clear(&mut self) {
        self.guid = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AvatarSwapNotify {
        static instance: AvatarSwapNotify = AvatarSwapNotify {
            guid: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AvatarSwapNotify {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AvatarSwapNotify").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AvatarSwapNotify {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AvatarSwapNotify {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Mualani.Guide.EquipSwapNotify)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EquipSwapNotify {
    // message fields
    // @@protoc_insertion_point(field:Mualani.Guide.EquipSwapNotify.avatar_guid)
    pub avatar_guid: u64,
    // @@protoc_insertion_point(field:Mualani.Guide.EquipSwapNotify.item_guid)
    pub item_guid: u64,
    // special fields
    // @@protoc_insertion_point(special_field:Mualani.Guide.EquipSwapNotify.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EquipSwapNotify {
    fn default() -> &'a EquipSwapNotify {
        <EquipSwapNotify as ::protobuf::Message>::default_instance()
    }
}

impl EquipSwapNotify {
    pub fn new() -> EquipSwapNotify {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "avatar_guid",
            |m: &EquipSwapNotify| { &m.avatar_guid },
            |m: &mut EquipSwapNotify| { &mut m.avatar_guid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "item_guid",
            |m: &EquipSwapNotify| { &m.item_guid },
            |m: &mut EquipSwapNotify| { &mut m.item_guid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EquipSwapNotify>(
            "EquipSwapNotify",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EquipSwapNotify {
    const NAME: &'static str = "EquipSwapNotify";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                48 => {
                    self.avatar_guid = is.read_uint64()?;
                },
                72 => {
                    self.item_guid = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.avatar_guid != 0 {
            my_size += ::protobuf::rt::uint64_size(6, self.avatar_guid);
        }
        if self.item_guid != 0 {
            my_size += ::protobuf::rt::uint64_size(9, self.item_guid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.avatar_guid != 0 {
            os.write_uint64(6, self.avatar_guid)?;
        }
        if self.item_guid != 0 {
            os.write_uint64(9, self.item_guid)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EquipSwapNotify {
        EquipSwapNotify::new()
    }

    fn clear(&mut self) {
        self.avatar_guid = 0;
        self.item_guid = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EquipSwapNotify {
        static instance: EquipSwapNotify = EquipSwapNotify {
            avatar_guid: 0,
            item_guid: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EquipSwapNotify {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EquipSwapNotify").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EquipSwapNotify {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EquipSwapNotify {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x12AvatarNotify.proto\x12\rMualani.Guide\"P\n\x10AvatarRenameInfo\x12\
    \x1b\n\tavatar_id\x18\x06\x20\x01(\rR\x08avatarId\x12\x1f\n\x0bavatar_na\
    me\x18\t\x20\x01(\tR\navatarName\"S\n\nAvatarTeam\x12(\n\x10avatar_guid_\
    list\x18\n\x20\x03(\x04R\x0eavatarGuidList\x12\x1b\n\tteam_name\x18\x04\
    \x20\x01(\tR\x08teamName\"o\n\x08Property\x12\x0e\n\x02id\x18\x01\x20\
    \x01(\rR\x02id\x12\x15\n\x03val\x18\x02\x20\x01(\x03H\0R\x03val\x88\x01\
    \x01\x12\x17\n\x04fval\x18\x03\x20\x01(\x02H\x01R\x04fval\x88\x01\x01\
    \x12\x12\n\x04ival\x18\x04\x20\x01(\x03R\x04ivalB\x06\n\x04_valB\x07\n\
    \x05_fval\"t\n\nFetterData\x12\x1b\n\tfetter_id\x18\x01\x20\x01(\rR\x08f\
    etterId\x12!\n\x0cfetter_state\x18\x02\x20\x01(\rR\x0bfetterState\x12&\n\
    \x0fcond_index_list\x18\x03\x20\x03(\rR\rcondIndexList\"\xe8\x01\n\nFett\
    erInfo\x12\x14\n\x05level\x18\x02\x20\x01(\rR\x05level\x12\x10\n\x03exp\
    \x18\x01\x20\x01(\rR\x03exp\x12\x20\n\x0copen_id_list\x18\x03\x20\x03(\r\
    R\nopenIdList\x12$\n\x0efinish_id_list\x18\x04\x20\x03(\rR\x0cfinishIdLi\
    st\x12;\n\x1arewarded_fetter_level_list\x18\x05\x20\x03(\rR\x17rewardedF\
    etterLevelList\x12-\n\x04data\x18\x06\x20\x03(\x0b2\x19.Mualani.Guide.Fe\
    tterDataR\x04data\"\x87\n\n\nAvatarInfo\x12\x1b\n\tavatar_id\x18\x01\x20\
    \x01(\rR\x08avatarId\x12\x12\n\x04guid\x18\x02\x20\x01(\x04R\x04guid\x12\
    :\n\x05props\x18\x03\x20\x03(\x0b2$.Mualani.Guide.AvatarInfo.PropsEntryR\
    \x05props\x12\x1d\n\nlife_state\x18\x04\x20\x01(\rR\tlifeState\x12&\n\
    \x0fequip_guid_list\x18\x05\x20\x03(\x04R\requipGuidList\x12$\n\x0etalen\
    t_id_list\x18\x06\x20\x03(\rR\x0ctalentIdList\x12Q\n\x0efight_prop_map\
    \x18\x07\x20\x03(\x0b2+.Mualani.Guide.AvatarInfo.FightPropMapEntryR\x0cf\
    ightPropMap\x121\n\x06fetter\x18\x0c\x20\x01(\x0b2\x19.Mualani.Guide.Fet\
    terInfoR\x06fetter\x12$\n\x0eskill_depot_id\x18\x0b\x20\x01(\rR\x0cskill\
    DepotId\x123\n\x16core_proud_skill_level\x18\r\x20\x01(\rR\x13coreProudS\
    killLevel\x129\n\x19inherent_proud_skill_list\x18\x0e\x20\x03(\rR\x16inh\
    erentProudSkillList\x12T\n\x0fskill_level_map\x18\x0f\x20\x03(\x0b2,.Mua\
    lani.Guide.AvatarInfo.SkillLevelMapEntryR\rskillLevelMap\x12t\n\x1bproud\
    _skill_extra_level_map\x18\x11\x20\x03(\x0b26.Mualani.Guide.AvatarInfo.P\
    roudSkillExtraLevelMapEntryR\x17proudSkillExtraLevelMap\x12\x19\n\x08is_\
    focus\x18\x12\x20\x01(\x08R\x07isFocus\x12\x1f\n\x0bavatar_type\x18\x13\
    \x20\x01(\rR\navatarType\x12.\n\x13team_resonance_list\x18\x14\x20\x03(\
    \rR\x11teamResonanceList\x12.\n\x13wearing_flycloak_id\x18\x15\x20\x01(\
    \rR\x11wearingFlycloakId\x12\x1b\n\tborn_time\x18\x17\x20\x01(\rR\x08bor\
    nTime\x12=\n\x1bpending_promote_reward_list\x18\x18\x20\x03(\rR\x18pendi\
    ngPromoteRewardList\x12\x1d\n\ncostume_id\x18\x19\x20\x01(\rR\tcostumeId\
    \x1aQ\n\nPropsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\rR\x03key\x12-\n\
    \x05value\x18\x02\x20\x01(\x0b2\x17.Mualani.Guide.PropertyR\x05value:\
    \x028\x01\x1a?\n\x11FightPropMapEntry\x12\x10\n\x03key\x18\x01\x20\x01(\
    \rR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x02R\x05value:\x028\x01\
    \x1a@\n\x12SkillLevelMapEntry\x12\x10\n\x03key\x18\x01\x20\x01(\rR\x03ke\
    y\x12\x14\n\x05value\x18\x02\x20\x01(\rR\x05value:\x028\x01\x1aJ\n\x1cPr\
    oudSkillExtraLevelMapEntry\x12\x10\n\x03key\x18\x01\x20\x01(\rR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\rR\x05value:\x028\x01\"\x8f\x04\n\
    \x0cAvatarNotify\x12\x1c\n\tflycloaks\x18\x04\x20\x03(\rR\tflycloaks\x12\
    !\n\x0cchoosen_guid\x18\x01\x20\x01(\x04R\x0bchoosenGuid\x12\x1a\n\x08co\
    stumes\x18\x02\x20\x03(\rR\x08costumes\x12\x1d\n\nteam_order\x18\r\x20\
    \x03(\rR\tteamOrder\x12V\n\x0favatar_team_map\x18\t\x20\x03(\x0b2..Muala\
    ni.Guide.AvatarNotify.AvatarTeamMapEntryR\ravatarTeamMap\x12+\n\x12cur_a\
    vatar_team_id\x18\x06\x20\x01(\rR\x0fcurAvatarTeamId\x121\n\x15temp_avat\
    ar_guid_list\x18b\x20\x03(\x04R\x12tempAvatarGuidList\x129\n\x07renames\
    \x18\x0f\x20\x03(\x0b2\x1f.Mualani.Guide.AvatarRenameInfoR\x07renames\
    \x123\n\x07avatars\x18\x07\x20\x03(\x0b2\x19.Mualani.Guide.AvatarInfoR\
    \x07avatars\x1a[\n\x12AvatarTeamMapEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\rR\x03key\x12/\n\x05value\x18\x02\x20\x01(\x0b2\x19.Mualani.Guide.\
    AvatarTeamR\x05value:\x028\x01\"F\n\x11AvatarAddedNotify\x121\n\x06avata\
    r\x18\x0e\x20\x01(\x0b2\x19.Mualani.Guide.AvatarInfoR\x06avatar\"\xaa\
    \x01\n\x11AvatarSkillUpdate\x12\x1f\n\x0bskill_depot\x18\x06\x20\x01(\rR\
    \nskillDepot\x12\x12\n\x04guid\x18\n\x20\x01(\x04R\x04guid\x12\x1b\n\tcu\
    r_level\x18\x03\x20\x01(\rR\x08curLevel\x12&\n\x0favatar_skill_id\x18\r\
    \x20\x01(\rR\ravatarSkillId\x12\x1b\n\told_level\x18\x02\x20\x01(\rR\x08\
    oldLevel\"\xaa\x01\n\x14AvatarPropertyUpdate\x12\x12\n\x04guid\x18\x06\
    \x20\x01(\x04R\x04guid\x12D\n\x05props\x18\x05\x20\x03(\x0b2..Mualani.Gu\
    ide.AvatarPropertyUpdate.PropsEntryR\x05props\x1a8\n\nPropsEntry\x12\x10\
    \n\x03key\x18\x01\x20\x01(\rR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \x03R\x05value:\x028\x01\"\xac\x01\n\x15AvatarFightPropUpdate\x12\x12\n\
    \x04guid\x18\x03\x20\x01(\x04R\x04guid\x12E\n\x05props\x18\x0c\x20\x03(\
    \x0b2/.Mualani.Guide.AvatarFightPropUpdate.PropsEntryR\x05props\x1a8\n\n\
    PropsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\rR\x03key\x12\x14\n\x05valu\
    e\x18\x02\x20\x01(\x02R\x05value:\x028\x01\"\xaa\x01\n\x15EntityFightPro\
    pUpdate\x12\x10\n\x03eid\x18\x0e\x20\x01(\x04R\x03eid\x12E\n\x05props\
    \x18\r\x20\x03(\x0b2/.Mualani.Guide.EntityFightPropUpdate.PropsEntryR\
    \x05props\x1a8\n\nPropsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\rR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\x02R\x05value:\x028\x01\"/\n\x0eTea\
    mSwapNotify\x12\x1d\n\ncurteam_id\x18\x08\x20\x01(\rR\tcurteamId\"&\n\
    \x10AvatarSwapNotify\x12\x12\n\x04guid\x18\x0e\x20\x01(\x04R\x04guid\"O\
    \n\x0fEquipSwapNotify\x12\x1f\n\x0bavatar_guid\x18\x06\x20\x01(\x04R\nav\
    atarGuid\x12\x1b\n\titem_guid\x18\t\x20\x01(\x04R\x08itemGuidb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(15);
            messages.push(AvatarRenameInfo::generated_message_descriptor_data());
            messages.push(AvatarTeam::generated_message_descriptor_data());
            messages.push(Property::generated_message_descriptor_data());
            messages.push(FetterData::generated_message_descriptor_data());
            messages.push(FetterInfo::generated_message_descriptor_data());
            messages.push(AvatarInfo::generated_message_descriptor_data());
            messages.push(AvatarNotify::generated_message_descriptor_data());
            messages.push(AvatarAddedNotify::generated_message_descriptor_data());
            messages.push(AvatarSkillUpdate::generated_message_descriptor_data());
            messages.push(AvatarPropertyUpdate::generated_message_descriptor_data());
            messages.push(AvatarFightPropUpdate::generated_message_descriptor_data());
            messages.push(EntityFightPropUpdate::generated_message_descriptor_data());
            messages.push(TeamSwapNotify::generated_message_descriptor_data());
            messages.push(AvatarSwapNotify::generated_message_descriptor_data());
            messages.push(EquipSwapNotify::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
