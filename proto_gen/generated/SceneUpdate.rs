// This file is generated by rust-protobuf 3.7.1. Do not edit
// .proto file is parsed by protoc 29.0-rc1
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `SceneUpdate.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_1;

// @@protoc_insertion_point(message:Mualani.Guide.MotionInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MotionInfo {
    // message fields
    // @@protoc_insertion_point(field:Mualani.Guide.MotionInfo.pos)
    pub pos: ::protobuf::MessageField<super::WorldPlayerLocationNotify::Vector>,
    // @@protoc_insertion_point(field:Mualani.Guide.MotionInfo.rot)
    pub rot: ::protobuf::MessageField<super::WorldPlayerLocationNotify::Vector>,
    // special fields
    // @@protoc_insertion_point(special_field:Mualani.Guide.MotionInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MotionInfo {
    fn default() -> &'a MotionInfo {
        <MotionInfo as ::protobuf::Message>::default_instance()
    }
}

impl MotionInfo {
    pub fn new() -> MotionInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::WorldPlayerLocationNotify::Vector>(
            "pos",
            |m: &MotionInfo| { &m.pos },
            |m: &mut MotionInfo| { &mut m.pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::WorldPlayerLocationNotify::Vector>(
            "rot",
            |m: &MotionInfo| { &m.rot },
            |m: &mut MotionInfo| { &mut m.rot },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MotionInfo>(
            "MotionInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MotionInfo {
    const NAME: &'static str = "MotionInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pos)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rot)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.rot.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.rot.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MotionInfo {
        MotionInfo::new()
    }

    fn clear(&mut self) {
        self.pos.clear();
        self.rot.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MotionInfo {
        static instance: MotionInfo = MotionInfo {
            pos: ::protobuf::MessageField::none(),
            rot: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MotionInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MotionInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MotionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MotionInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Mualani.Guide.SceneAvatarInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SceneAvatarInfo {
    // message fields
    // @@protoc_insertion_point(field:Mualani.Guide.SceneAvatarInfo.uid)
    pub uid: u32,
    // @@protoc_insertion_point(field:Mualani.Guide.SceneAvatarInfo.av_id)
    pub av_id: u32,
    // @@protoc_insertion_point(field:Mualani.Guide.SceneAvatarInfo.guid)
    pub guid: u64,
    // @@protoc_insertion_point(field:Mualani.Guide.SceneAvatarInfo.peer_id)
    pub peer_id: u32,
    // @@protoc_insertion_point(field:Mualani.Guide.SceneAvatarInfo.equips)
    pub equips: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:Mualani.Guide.SceneAvatarInfo.skill_dep_id)
    pub skill_dep_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:Mualani.Guide.SceneAvatarInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SceneAvatarInfo {
    fn default() -> &'a SceneAvatarInfo {
        <SceneAvatarInfo as ::protobuf::Message>::default_instance()
    }
}

impl SceneAvatarInfo {
    pub fn new() -> SceneAvatarInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "uid",
            |m: &SceneAvatarInfo| { &m.uid },
            |m: &mut SceneAvatarInfo| { &mut m.uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "av_id",
            |m: &SceneAvatarInfo| { &m.av_id },
            |m: &mut SceneAvatarInfo| { &mut m.av_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "guid",
            |m: &SceneAvatarInfo| { &m.guid },
            |m: &mut SceneAvatarInfo| { &mut m.guid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "peer_id",
            |m: &SceneAvatarInfo| { &m.peer_id },
            |m: &mut SceneAvatarInfo| { &mut m.peer_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "equips",
            |m: &SceneAvatarInfo| { &m.equips },
            |m: &mut SceneAvatarInfo| { &mut m.equips },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "skill_dep_id",
            |m: &SceneAvatarInfo| { &m.skill_dep_id },
            |m: &mut SceneAvatarInfo| { &mut m.skill_dep_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SceneAvatarInfo>(
            "SceneAvatarInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SceneAvatarInfo {
    const NAME: &'static str = "SceneAvatarInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.uid = is.read_uint32()?;
                },
                16 => {
                    self.av_id = is.read_uint32()?;
                },
                24 => {
                    self.guid = is.read_uint64()?;
                },
                32 => {
                    self.peer_id = is.read_uint32()?;
                },
                42 => {
                    is.read_repeated_packed_uint32_into(&mut self.equips)?;
                },
                40 => {
                    self.equips.push(is.read_uint32()?);
                },
                48 => {
                    self.skill_dep_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.uid != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.uid);
        }
        if self.av_id != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.av_id);
        }
        if self.guid != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.guid);
        }
        if self.peer_id != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.peer_id);
        }
        my_size += ::protobuf::rt::vec_packed_uint32_size(5, &self.equips);
        if self.skill_dep_id != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.skill_dep_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.uid != 0 {
            os.write_uint32(1, self.uid)?;
        }
        if self.av_id != 0 {
            os.write_uint32(2, self.av_id)?;
        }
        if self.guid != 0 {
            os.write_uint64(3, self.guid)?;
        }
        if self.peer_id != 0 {
            os.write_uint32(4, self.peer_id)?;
        }
        os.write_repeated_packed_uint32(5, &self.equips)?;
        if self.skill_dep_id != 0 {
            os.write_uint32(6, self.skill_dep_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SceneAvatarInfo {
        SceneAvatarInfo::new()
    }

    fn clear(&mut self) {
        self.uid = 0;
        self.av_id = 0;
        self.guid = 0;
        self.peer_id = 0;
        self.equips.clear();
        self.skill_dep_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SceneAvatarInfo {
        static instance: SceneAvatarInfo = SceneAvatarInfo {
            uid: 0,
            av_id: 0,
            guid: 0,
            peer_id: 0,
            equips: ::std::vec::Vec::new(),
            skill_dep_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SceneAvatarInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SceneAvatarInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SceneAvatarInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SceneAvatarInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Mualani.Guide.SceneMonsterInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SceneMonsterInfo {
    // message fields
    // @@protoc_insertion_point(field:Mualani.Guide.SceneMonsterInfo.monster_id)
    pub monster_id: u32,
    // @@protoc_insertion_point(field:Mualani.Guide.SceneMonsterInfo.group_id)
    pub group_id: u32,
    // @@protoc_insertion_point(field:Mualani.Guide.SceneMonsterInfo.config_id)
    pub config_id: u32,
    // @@protoc_insertion_point(field:Mualani.Guide.SceneMonsterInfo.elite)
    pub elite: bool,
    // @@protoc_insertion_point(field:Mualani.Guide.SceneMonsterInfo.owner)
    pub owner: u32,
    // special fields
    // @@protoc_insertion_point(special_field:Mualani.Guide.SceneMonsterInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SceneMonsterInfo {
    fn default() -> &'a SceneMonsterInfo {
        <SceneMonsterInfo as ::protobuf::Message>::default_instance()
    }
}

impl SceneMonsterInfo {
    pub fn new() -> SceneMonsterInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "monster_id",
            |m: &SceneMonsterInfo| { &m.monster_id },
            |m: &mut SceneMonsterInfo| { &mut m.monster_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "group_id",
            |m: &SceneMonsterInfo| { &m.group_id },
            |m: &mut SceneMonsterInfo| { &mut m.group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "config_id",
            |m: &SceneMonsterInfo| { &m.config_id },
            |m: &mut SceneMonsterInfo| { &mut m.config_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "elite",
            |m: &SceneMonsterInfo| { &m.elite },
            |m: &mut SceneMonsterInfo| { &mut m.elite },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "owner",
            |m: &SceneMonsterInfo| { &m.owner },
            |m: &mut SceneMonsterInfo| { &mut m.owner },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SceneMonsterInfo>(
            "SceneMonsterInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SceneMonsterInfo {
    const NAME: &'static str = "SceneMonsterInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.monster_id = is.read_uint32()?;
                },
                16 => {
                    self.group_id = is.read_uint32()?;
                },
                24 => {
                    self.config_id = is.read_uint32()?;
                },
                56 => {
                    self.elite = is.read_bool()?;
                },
                64 => {
                    self.owner = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.monster_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.monster_id);
        }
        if self.group_id != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.group_id);
        }
        if self.config_id != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.config_id);
        }
        if self.elite != false {
            my_size += 1 + 1;
        }
        if self.owner != 0 {
            my_size += ::protobuf::rt::uint32_size(8, self.owner);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.monster_id != 0 {
            os.write_uint32(1, self.monster_id)?;
        }
        if self.group_id != 0 {
            os.write_uint32(2, self.group_id)?;
        }
        if self.config_id != 0 {
            os.write_uint32(3, self.config_id)?;
        }
        if self.elite != false {
            os.write_bool(7, self.elite)?;
        }
        if self.owner != 0 {
            os.write_uint32(8, self.owner)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SceneMonsterInfo {
        SceneMonsterInfo::new()
    }

    fn clear(&mut self) {
        self.monster_id = 0;
        self.group_id = 0;
        self.config_id = 0;
        self.elite = false;
        self.owner = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SceneMonsterInfo {
        static instance: SceneMonsterInfo = SceneMonsterInfo {
            monster_id: 0,
            group_id: 0,
            config_id: 0,
            elite: false,
            owner: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SceneMonsterInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SceneMonsterInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SceneMonsterInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SceneMonsterInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Mualani.Guide.SceneNPCInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SceneNPCInfo {
    // message fields
    // @@protoc_insertion_point(field:Mualani.Guide.SceneNPCInfo.npc_id)
    pub npc_id: u32,
    // @@protoc_insertion_point(field:Mualani.Guide.SceneNPCInfo.room_id)
    pub room_id: u32,
    // @@protoc_insertion_point(field:Mualani.Guide.SceneNPCInfo.parent_quest_id)
    pub parent_quest_id: u32,
    // @@protoc_insertion_point(field:Mualani.Guide.SceneNPCInfo.block_id)
    pub block_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:Mualani.Guide.SceneNPCInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SceneNPCInfo {
    fn default() -> &'a SceneNPCInfo {
        <SceneNPCInfo as ::protobuf::Message>::default_instance()
    }
}

impl SceneNPCInfo {
    pub fn new() -> SceneNPCInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "npc_id",
            |m: &SceneNPCInfo| { &m.npc_id },
            |m: &mut SceneNPCInfo| { &mut m.npc_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "room_id",
            |m: &SceneNPCInfo| { &m.room_id },
            |m: &mut SceneNPCInfo| { &mut m.room_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "parent_quest_id",
            |m: &SceneNPCInfo| { &m.parent_quest_id },
            |m: &mut SceneNPCInfo| { &mut m.parent_quest_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "block_id",
            |m: &SceneNPCInfo| { &m.block_id },
            |m: &mut SceneNPCInfo| { &mut m.block_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SceneNPCInfo>(
            "SceneNPCInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SceneNPCInfo {
    const NAME: &'static str = "SceneNPCInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.npc_id = is.read_uint32()?;
                },
                16 => {
                    self.room_id = is.read_uint32()?;
                },
                24 => {
                    self.parent_quest_id = is.read_uint32()?;
                },
                32 => {
                    self.block_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.npc_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.npc_id);
        }
        if self.room_id != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.room_id);
        }
        if self.parent_quest_id != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.parent_quest_id);
        }
        if self.block_id != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.block_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.npc_id != 0 {
            os.write_uint32(1, self.npc_id)?;
        }
        if self.room_id != 0 {
            os.write_uint32(2, self.room_id)?;
        }
        if self.parent_quest_id != 0 {
            os.write_uint32(3, self.parent_quest_id)?;
        }
        if self.block_id != 0 {
            os.write_uint32(4, self.block_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SceneNPCInfo {
        SceneNPCInfo::new()
    }

    fn clear(&mut self) {
        self.npc_id = 0;
        self.room_id = 0;
        self.parent_quest_id = 0;
        self.block_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SceneNPCInfo {
        static instance: SceneNPCInfo = SceneNPCInfo {
            npc_id: 0,
            room_id: 0,
            parent_quest_id: 0,
            block_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SceneNPCInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SceneNPCInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SceneNPCInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SceneNPCInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Mualani.Guide.SceneGadgetInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SceneGadgetInfo {
    // message fields
    // @@protoc_insertion_point(field:Mualani.Guide.SceneGadgetInfo.gadget_id)
    pub gadget_id: u32,
    // @@protoc_insertion_point(field:Mualani.Guide.SceneGadgetInfo.group_id)
    pub group_id: u32,
    // @@protoc_insertion_point(field:Mualani.Guide.SceneGadgetInfo.config_id)
    pub config_id: u32,
    // @@protoc_insertion_point(field:Mualani.Guide.SceneGadgetInfo.owner_entity_id)
    pub owner_entity_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:Mualani.Guide.SceneGadgetInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SceneGadgetInfo {
    fn default() -> &'a SceneGadgetInfo {
        <SceneGadgetInfo as ::protobuf::Message>::default_instance()
    }
}

impl SceneGadgetInfo {
    pub fn new() -> SceneGadgetInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "gadget_id",
            |m: &SceneGadgetInfo| { &m.gadget_id },
            |m: &mut SceneGadgetInfo| { &mut m.gadget_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "group_id",
            |m: &SceneGadgetInfo| { &m.group_id },
            |m: &mut SceneGadgetInfo| { &mut m.group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "config_id",
            |m: &SceneGadgetInfo| { &m.config_id },
            |m: &mut SceneGadgetInfo| { &mut m.config_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "owner_entity_id",
            |m: &SceneGadgetInfo| { &m.owner_entity_id },
            |m: &mut SceneGadgetInfo| { &mut m.owner_entity_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SceneGadgetInfo>(
            "SceneGadgetInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SceneGadgetInfo {
    const NAME: &'static str = "SceneGadgetInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.gadget_id = is.read_uint32()?;
                },
                16 => {
                    self.group_id = is.read_uint32()?;
                },
                24 => {
                    self.config_id = is.read_uint32()?;
                },
                32 => {
                    self.owner_entity_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.gadget_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.gadget_id);
        }
        if self.group_id != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.group_id);
        }
        if self.config_id != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.config_id);
        }
        if self.owner_entity_id != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.owner_entity_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.gadget_id != 0 {
            os.write_uint32(1, self.gadget_id)?;
        }
        if self.group_id != 0 {
            os.write_uint32(2, self.group_id)?;
        }
        if self.config_id != 0 {
            os.write_uint32(3, self.config_id)?;
        }
        if self.owner_entity_id != 0 {
            os.write_uint32(4, self.owner_entity_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SceneGadgetInfo {
        SceneGadgetInfo::new()
    }

    fn clear(&mut self) {
        self.gadget_id = 0;
        self.group_id = 0;
        self.config_id = 0;
        self.owner_entity_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SceneGadgetInfo {
        static instance: SceneGadgetInfo = SceneGadgetInfo {
            gadget_id: 0,
            group_id: 0,
            config_id: 0,
            owner_entity_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SceneGadgetInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SceneGadgetInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SceneGadgetInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SceneGadgetInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Mualani.Guide.EntityInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EntityInfo {
    // message fields
    // @@protoc_insertion_point(field:Mualani.Guide.EntityInfo.type)
    pub type_: ::protobuf::EnumOrUnknown<EntityType>,
    // @@protoc_insertion_point(field:Mualani.Guide.EntityInfo.id)
    pub id: u32,
    // @@protoc_insertion_point(field:Mualani.Guide.EntityInfo.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:Mualani.Guide.EntityInfo.motion)
    pub motion: ::protobuf::MessageField<MotionInfo>,
    // @@protoc_insertion_point(field:Mualani.Guide.EntityInfo.Props)
    pub Props: ::std::collections::HashMap<u32, super::AvatarNotify::Property>,
    // @@protoc_insertion_point(field:Mualani.Guide.EntityInfo.FProps)
    pub FProps: ::std::collections::HashMap<u32, f32>,
    // @@protoc_insertion_point(field:Mualani.Guide.EntityInfo.life_state)
    pub life_state: u32,
    // @@protoc_insertion_point(field:Mualani.Guide.EntityInfo.av)
    pub av: ::protobuf::MessageField<SceneAvatarInfo>,
    // @@protoc_insertion_point(field:Mualani.Guide.EntityInfo.mon)
    pub mon: ::protobuf::MessageField<SceneMonsterInfo>,
    // @@protoc_insertion_point(field:Mualani.Guide.EntityInfo.npc)
    pub npc: ::protobuf::MessageField<SceneNPCInfo>,
    // @@protoc_insertion_point(field:Mualani.Guide.EntityInfo.gadget)
    pub gadget: ::protobuf::MessageField<SceneGadgetInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:Mualani.Guide.EntityInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EntityInfo {
    fn default() -> &'a EntityInfo {
        <EntityInfo as ::protobuf::Message>::default_instance()
    }
}

impl EntityInfo {
    pub fn new() -> EntityInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &EntityInfo| { &m.type_ },
            |m: &mut EntityInfo| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &EntityInfo| { &m.id },
            |m: &mut EntityInfo| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &EntityInfo| { &m.name },
            |m: &mut EntityInfo| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MotionInfo>(
            "motion",
            |m: &EntityInfo| { &m.motion },
            |m: &mut EntityInfo| { &mut m.motion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "Props",
            |m: &EntityInfo| { &m.Props },
            |m: &mut EntityInfo| { &mut m.Props },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "FProps",
            |m: &EntityInfo| { &m.FProps },
            |m: &mut EntityInfo| { &mut m.FProps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "life_state",
            |m: &EntityInfo| { &m.life_state },
            |m: &mut EntityInfo| { &mut m.life_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SceneAvatarInfo>(
            "av",
            |m: &EntityInfo| { &m.av },
            |m: &mut EntityInfo| { &mut m.av },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SceneMonsterInfo>(
            "mon",
            |m: &EntityInfo| { &m.mon },
            |m: &mut EntityInfo| { &mut m.mon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SceneNPCInfo>(
            "npc",
            |m: &EntityInfo| { &m.npc },
            |m: &mut EntityInfo| { &mut m.npc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SceneGadgetInfo>(
            "gadget",
            |m: &EntityInfo| { &m.gadget },
            |m: &mut EntityInfo| { &mut m.gadget },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EntityInfo>(
            "EntityInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EntityInfo {
    const NAME: &'static str = "EntityInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.id = is.read_uint32()?;
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.motion)?;
                },
                42 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => key = is.read_uint32()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.Props.insert(key, value);
                },
                50 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => key = is.read_uint32()?,
                            21 => value = is.read_float()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.FProps.insert(key, value);
                },
                56 => {
                    self.life_state = is.read_uint32()?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.av)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.mon)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.npc)?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.gadget)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(EntityType::ENTITY_NONE) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.id);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.motion.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for (k, v) in &self.Props {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::uint32_size(1, *k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.FProps {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::uint32_size(1, *k);
            entry_size += 1 + 4;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if self.life_state != 0 {
            my_size += ::protobuf::rt::uint32_size(7, self.life_state);
        }
        if let Some(v) = self.av.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.mon.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.npc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.gadget.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(EntityType::ENTITY_NONE) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if self.id != 0 {
            os.write_uint32(2, self.id)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.motion.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        for (k, v) in &self.Props {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::uint32_size(1, *k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(42)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_uint32(1, *k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.FProps {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::uint32_size(1, *k);
            entry_size += 1 + 4;
            os.write_raw_varint32(50)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_uint32(1, *k)?;
            os.write_float(2, *v)?;
        };
        if self.life_state != 0 {
            os.write_uint32(7, self.life_state)?;
        }
        if let Some(v) = self.av.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.mon.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.npc.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.gadget.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EntityInfo {
        EntityInfo::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(EntityType::ENTITY_NONE);
        self.id = 0;
        self.name = ::std::option::Option::None;
        self.motion.clear();
        self.Props.clear();
        self.FProps.clear();
        self.life_state = 0;
        self.av.clear();
        self.mon.clear();
        self.npc.clear();
        self.gadget.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EntityInfo {
        static instance: ::protobuf::rt::Lazy<EntityInfo> = ::protobuf::rt::Lazy::new();
        instance.get(EntityInfo::new)
    }
}

impl ::protobuf::MessageFull for EntityInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EntityInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EntityInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EntityInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Mualani.Guide.SceneUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SceneUpdate {
    // message fields
    // @@protoc_insertion_point(field:Mualani.Guide.SceneUpdate.param)
    pub param: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:Mualani.Guide.SceneUpdate.appear_type)
    pub appear_type: ::protobuf::EnumOrUnknown<VisionType>,
    // @@protoc_insertion_point(field:Mualani.Guide.SceneUpdate.entities)
    pub entities: ::std::vec::Vec<EntityInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:Mualani.Guide.SceneUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SceneUpdate {
    fn default() -> &'a SceneUpdate {
        <SceneUpdate as ::protobuf::Message>::default_instance()
    }
}

impl SceneUpdate {
    pub fn new() -> SceneUpdate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "param",
            |m: &SceneUpdate| { &m.param },
            |m: &mut SceneUpdate| { &mut m.param },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "appear_type",
            |m: &SceneUpdate| { &m.appear_type },
            |m: &mut SceneUpdate| { &mut m.appear_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entities",
            |m: &SceneUpdate| { &m.entities },
            |m: &mut SceneUpdate| { &mut m.entities },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SceneUpdate>(
            "SceneUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SceneUpdate {
    const NAME: &'static str = "SceneUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                792 => {
                    self.param = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.appear_type = is.read_enum_or_unknown()?;
                },
                10 => {
                    self.entities.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.param {
            my_size += ::protobuf::rt::uint32_size(99, v);
        }
        if self.appear_type != ::protobuf::EnumOrUnknown::new(VisionType::VISION_TYPE_NONE) {
            my_size += ::protobuf::rt::int32_size(7, self.appear_type.value());
        }
        for value in &self.entities {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.param {
            os.write_uint32(99, v)?;
        }
        if self.appear_type != ::protobuf::EnumOrUnknown::new(VisionType::VISION_TYPE_NONE) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.appear_type))?;
        }
        for v in &self.entities {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SceneUpdate {
        SceneUpdate::new()
    }

    fn clear(&mut self) {
        self.param = ::std::option::Option::None;
        self.appear_type = ::protobuf::EnumOrUnknown::new(VisionType::VISION_TYPE_NONE);
        self.entities.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SceneUpdate {
        static instance: SceneUpdate = SceneUpdate {
            param: ::std::option::Option::None,
            appear_type: ::protobuf::EnumOrUnknown::from_i32(0),
            entities: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SceneUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SceneUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SceneUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SceneUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Mualani.Guide.SceneEntityDieUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SceneEntityDieUpdate {
    // message fields
    // @@protoc_insertion_point(field:Mualani.Guide.SceneEntityDieUpdate.type)
    pub type_: ::protobuf::EnumOrUnknown<VisionType>,
    // @@protoc_insertion_point(field:Mualani.Guide.SceneEntityDieUpdate.param)
    pub param: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:Mualani.Guide.SceneEntityDieUpdate.eids)
    pub eids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:Mualani.Guide.SceneEntityDieUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SceneEntityDieUpdate {
    fn default() -> &'a SceneEntityDieUpdate {
        <SceneEntityDieUpdate as ::protobuf::Message>::default_instance()
    }
}

impl SceneEntityDieUpdate {
    pub fn new() -> SceneEntityDieUpdate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &SceneEntityDieUpdate| { &m.type_ },
            |m: &mut SceneEntityDieUpdate| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "param",
            |m: &SceneEntityDieUpdate| { &m.param },
            |m: &mut SceneEntityDieUpdate| { &mut m.param },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "eids",
            |m: &SceneEntityDieUpdate| { &m.eids },
            |m: &mut SceneEntityDieUpdate| { &mut m.eids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SceneEntityDieUpdate>(
            "SceneEntityDieUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SceneEntityDieUpdate {
    const NAME: &'static str = "SceneEntityDieUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                792 => {
                    self.param = ::std::option::Option::Some(is.read_uint32()?);
                },
                114 => {
                    is.read_repeated_packed_uint64_into(&mut self.eids)?;
                },
                112 => {
                    self.eids.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(VisionType::VISION_TYPE_NONE) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if let Some(v) = self.param {
            my_size += ::protobuf::rt::uint32_size(99, v);
        }
        my_size += ::protobuf::rt::vec_packed_uint64_size(14, &self.eids);
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(VisionType::VISION_TYPE_NONE) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if let Some(v) = self.param {
            os.write_uint32(99, v)?;
        }
        os.write_repeated_packed_uint64(14, &self.eids)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SceneEntityDieUpdate {
        SceneEntityDieUpdate::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(VisionType::VISION_TYPE_NONE);
        self.param = ::std::option::Option::None;
        self.eids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SceneEntityDieUpdate {
        static instance: SceneEntityDieUpdate = SceneEntityDieUpdate {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            param: ::std::option::Option::None,
            eids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SceneEntityDieUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SceneEntityDieUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SceneEntityDieUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SceneEntityDieUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:Mualani.Guide.EntityType)
pub enum EntityType {
    // @@protoc_insertion_point(enum_value:Mualani.Guide.EntityType.ENTITY_NONE)
    ENTITY_NONE = 0,
    // @@protoc_insertion_point(enum_value:Mualani.Guide.EntityType.ENTITY_AVATAR)
    ENTITY_AVATAR = 1,
    // @@protoc_insertion_point(enum_value:Mualani.Guide.EntityType.ENTITY_MONSTER)
    ENTITY_MONSTER = 2,
    // @@protoc_insertion_point(enum_value:Mualani.Guide.EntityType.ENTITY_NPC)
    ENTITY_NPC = 3,
    // @@protoc_insertion_point(enum_value:Mualani.Guide.EntityType.ENTITY_GADGET)
    ENTITY_GADGET = 4,
    // @@protoc_insertion_point(enum_value:Mualani.Guide.EntityType.ENTITY_REGION)
    ENTITY_REGION = 5,
    // @@protoc_insertion_point(enum_value:Mualani.Guide.EntityType.ENTITY_WEAPON)
    ENTITY_WEAPON = 6,
    // @@protoc_insertion_point(enum_value:Mualani.Guide.EntityType.ENTITY_WEATHER)
    ENTITY_WEATHER = 7,
    // @@protoc_insertion_point(enum_value:Mualani.Guide.EntityType.ENTITY_SCENE)
    ENTITY_SCENE = 8,
    // @@protoc_insertion_point(enum_value:Mualani.Guide.EntityType.ENTITY_TEAM)
    ENTITY_TEAM = 9,
    // @@protoc_insertion_point(enum_value:Mualani.Guide.EntityType.ENTITY_MASSIVE)
    ENTITY_MASSIVE = 10,
    // @@protoc_insertion_point(enum_value:Mualani.Guide.EntityType.ENTITY_MP_LVL)
    ENTITY_MP_LVL = 11,
    // @@protoc_insertion_point(enum_value:Mualani.Guide.EntityType.ENTITY_PLAY_TEAM)
    ENTITY_PLAY_TEAM = 12,
    // @@protoc_insertion_point(enum_value:Mualani.Guide.EntityType.ENTITY_EYEPOINT)
    ENTITY_EYEPOINT = 13,
    // @@protoc_insertion_point(enum_value:Mualani.Guide.EntityType.ENTITY_MAX)
    ENTITY_MAX = 14,
}

impl ::protobuf::Enum for EntityType {
    const NAME: &'static str = "EntityType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EntityType> {
        match value {
            0 => ::std::option::Option::Some(EntityType::ENTITY_NONE),
            1 => ::std::option::Option::Some(EntityType::ENTITY_AVATAR),
            2 => ::std::option::Option::Some(EntityType::ENTITY_MONSTER),
            3 => ::std::option::Option::Some(EntityType::ENTITY_NPC),
            4 => ::std::option::Option::Some(EntityType::ENTITY_GADGET),
            5 => ::std::option::Option::Some(EntityType::ENTITY_REGION),
            6 => ::std::option::Option::Some(EntityType::ENTITY_WEAPON),
            7 => ::std::option::Option::Some(EntityType::ENTITY_WEATHER),
            8 => ::std::option::Option::Some(EntityType::ENTITY_SCENE),
            9 => ::std::option::Option::Some(EntityType::ENTITY_TEAM),
            10 => ::std::option::Option::Some(EntityType::ENTITY_MASSIVE),
            11 => ::std::option::Option::Some(EntityType::ENTITY_MP_LVL),
            12 => ::std::option::Option::Some(EntityType::ENTITY_PLAY_TEAM),
            13 => ::std::option::Option::Some(EntityType::ENTITY_EYEPOINT),
            14 => ::std::option::Option::Some(EntityType::ENTITY_MAX),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EntityType> {
        match str {
            "ENTITY_NONE" => ::std::option::Option::Some(EntityType::ENTITY_NONE),
            "ENTITY_AVATAR" => ::std::option::Option::Some(EntityType::ENTITY_AVATAR),
            "ENTITY_MONSTER" => ::std::option::Option::Some(EntityType::ENTITY_MONSTER),
            "ENTITY_NPC" => ::std::option::Option::Some(EntityType::ENTITY_NPC),
            "ENTITY_GADGET" => ::std::option::Option::Some(EntityType::ENTITY_GADGET),
            "ENTITY_REGION" => ::std::option::Option::Some(EntityType::ENTITY_REGION),
            "ENTITY_WEAPON" => ::std::option::Option::Some(EntityType::ENTITY_WEAPON),
            "ENTITY_WEATHER" => ::std::option::Option::Some(EntityType::ENTITY_WEATHER),
            "ENTITY_SCENE" => ::std::option::Option::Some(EntityType::ENTITY_SCENE),
            "ENTITY_TEAM" => ::std::option::Option::Some(EntityType::ENTITY_TEAM),
            "ENTITY_MASSIVE" => ::std::option::Option::Some(EntityType::ENTITY_MASSIVE),
            "ENTITY_MP_LVL" => ::std::option::Option::Some(EntityType::ENTITY_MP_LVL),
            "ENTITY_PLAY_TEAM" => ::std::option::Option::Some(EntityType::ENTITY_PLAY_TEAM),
            "ENTITY_EYEPOINT" => ::std::option::Option::Some(EntityType::ENTITY_EYEPOINT),
            "ENTITY_MAX" => ::std::option::Option::Some(EntityType::ENTITY_MAX),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EntityType] = &[
        EntityType::ENTITY_NONE,
        EntityType::ENTITY_AVATAR,
        EntityType::ENTITY_MONSTER,
        EntityType::ENTITY_NPC,
        EntityType::ENTITY_GADGET,
        EntityType::ENTITY_REGION,
        EntityType::ENTITY_WEAPON,
        EntityType::ENTITY_WEATHER,
        EntityType::ENTITY_SCENE,
        EntityType::ENTITY_TEAM,
        EntityType::ENTITY_MASSIVE,
        EntityType::ENTITY_MP_LVL,
        EntityType::ENTITY_PLAY_TEAM,
        EntityType::ENTITY_EYEPOINT,
        EntityType::ENTITY_MAX,
    ];
}

impl ::protobuf::EnumFull for EntityType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EntityType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EntityType {
    fn default() -> Self {
        EntityType::ENTITY_NONE
    }
}

impl EntityType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EntityType>("EntityType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:Mualani.Guide.VisionType)
pub enum VisionType {
    // @@protoc_insertion_point(enum_value:Mualani.Guide.VisionType.VISION_TYPE_NONE)
    VISION_TYPE_NONE = 0,
    // @@protoc_insertion_point(enum_value:Mualani.Guide.VisionType.VISION_TYPE_MEET)
    VISION_TYPE_MEET = 1,
    // @@protoc_insertion_point(enum_value:Mualani.Guide.VisionType.VISION_TYPE_REBORN)
    VISION_TYPE_REBORN = 2,
    // @@protoc_insertion_point(enum_value:Mualani.Guide.VisionType.VISION_TYPE_REPLACE)
    VISION_TYPE_REPLACE = 3,
    // @@protoc_insertion_point(enum_value:Mualani.Guide.VisionType.VISION_TYPE_WAYPOINT_REBORN)
    VISION_TYPE_WAYPOINT_REBORN = 4,
    // @@protoc_insertion_point(enum_value:Mualani.Guide.VisionType.VISION_TYPE_TYPE_MISS)
    VISION_TYPE_TYPE_MISS = 5,
    // @@protoc_insertion_point(enum_value:Mualani.Guide.VisionType.VISION_TYPE_DIE)
    VISION_TYPE_DIE = 6,
    // @@protoc_insertion_point(enum_value:Mualani.Guide.VisionType.VISION_TYPE_GATHER_ESCAPE)
    VISION_TYPE_GATHER_ESCAPE = 7,
    // @@protoc_insertion_point(enum_value:Mualani.Guide.VisionType.VISION_TYPE_REFRESH)
    VISION_TYPE_REFRESH = 8,
    // @@protoc_insertion_point(enum_value:Mualani.Guide.VisionType.VISION_TYPE_TRANSPORT)
    VISION_TYPE_TRANSPORT = 9,
    // @@protoc_insertion_point(enum_value:Mualani.Guide.VisionType.VISION_TYPE_REPLACE_DIE)
    VISION_TYPE_REPLACE_DIE = 10,
    // @@protoc_insertion_point(enum_value:Mualani.Guide.VisionType.VISION_TYPE_REPLACE_NO_NOTIFY)
    VISION_TYPE_REPLACE_NO_NOTIFY = 11,
    // @@protoc_insertion_point(enum_value:Mualani.Guide.VisionType.VISION_TYPE_BORN)
    VISION_TYPE_BORN = 12,
    // @@protoc_insertion_point(enum_value:Mualani.Guide.VisionType.VISION_TYPE_PICKUP)
    VISION_TYPE_PICKUP = 13,
    // @@protoc_insertion_point(enum_value:Mualani.Guide.VisionType.VISION_TYPE_REMOVE)
    VISION_TYPE_REMOVE = 14,
    // @@protoc_insertion_point(enum_value:Mualani.Guide.VisionType.VISION_TYPE_FISH_REFRESH)
    VISION_TYPE_FISH_REFRESH = 16,
    // @@protoc_insertion_point(enum_value:Mualani.Guide.VisionType.VISION_TYPE_FISH_BIG_SHOCK)
    VISION_TYPE_FISH_BIG_SHOCK = 17,
    // @@protoc_insertion_point(enum_value:Mualani.Guide.VisionType.VISION_TYPE_FISH_QTE_SUCC)
    VISION_TYPE_FISH_QTE_SUCC = 18,
    // @@protoc_insertion_point(enum_value:Mualani.Guide.VisionType.VISION_TYPE_CAPTURE_DISAPPEAR)
    VISION_TYPE_CAPTURE_DISAPPEAR = 19,
}

impl ::protobuf::Enum for VisionType {
    const NAME: &'static str = "VisionType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<VisionType> {
        match value {
            0 => ::std::option::Option::Some(VisionType::VISION_TYPE_NONE),
            1 => ::std::option::Option::Some(VisionType::VISION_TYPE_MEET),
            2 => ::std::option::Option::Some(VisionType::VISION_TYPE_REBORN),
            3 => ::std::option::Option::Some(VisionType::VISION_TYPE_REPLACE),
            4 => ::std::option::Option::Some(VisionType::VISION_TYPE_WAYPOINT_REBORN),
            5 => ::std::option::Option::Some(VisionType::VISION_TYPE_TYPE_MISS),
            6 => ::std::option::Option::Some(VisionType::VISION_TYPE_DIE),
            7 => ::std::option::Option::Some(VisionType::VISION_TYPE_GATHER_ESCAPE),
            8 => ::std::option::Option::Some(VisionType::VISION_TYPE_REFRESH),
            9 => ::std::option::Option::Some(VisionType::VISION_TYPE_TRANSPORT),
            10 => ::std::option::Option::Some(VisionType::VISION_TYPE_REPLACE_DIE),
            11 => ::std::option::Option::Some(VisionType::VISION_TYPE_REPLACE_NO_NOTIFY),
            12 => ::std::option::Option::Some(VisionType::VISION_TYPE_BORN),
            13 => ::std::option::Option::Some(VisionType::VISION_TYPE_PICKUP),
            14 => ::std::option::Option::Some(VisionType::VISION_TYPE_REMOVE),
            16 => ::std::option::Option::Some(VisionType::VISION_TYPE_FISH_REFRESH),
            17 => ::std::option::Option::Some(VisionType::VISION_TYPE_FISH_BIG_SHOCK),
            18 => ::std::option::Option::Some(VisionType::VISION_TYPE_FISH_QTE_SUCC),
            19 => ::std::option::Option::Some(VisionType::VISION_TYPE_CAPTURE_DISAPPEAR),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<VisionType> {
        match str {
            "VISION_TYPE_NONE" => ::std::option::Option::Some(VisionType::VISION_TYPE_NONE),
            "VISION_TYPE_MEET" => ::std::option::Option::Some(VisionType::VISION_TYPE_MEET),
            "VISION_TYPE_REBORN" => ::std::option::Option::Some(VisionType::VISION_TYPE_REBORN),
            "VISION_TYPE_REPLACE" => ::std::option::Option::Some(VisionType::VISION_TYPE_REPLACE),
            "VISION_TYPE_WAYPOINT_REBORN" => ::std::option::Option::Some(VisionType::VISION_TYPE_WAYPOINT_REBORN),
            "VISION_TYPE_TYPE_MISS" => ::std::option::Option::Some(VisionType::VISION_TYPE_TYPE_MISS),
            "VISION_TYPE_DIE" => ::std::option::Option::Some(VisionType::VISION_TYPE_DIE),
            "VISION_TYPE_GATHER_ESCAPE" => ::std::option::Option::Some(VisionType::VISION_TYPE_GATHER_ESCAPE),
            "VISION_TYPE_REFRESH" => ::std::option::Option::Some(VisionType::VISION_TYPE_REFRESH),
            "VISION_TYPE_TRANSPORT" => ::std::option::Option::Some(VisionType::VISION_TYPE_TRANSPORT),
            "VISION_TYPE_REPLACE_DIE" => ::std::option::Option::Some(VisionType::VISION_TYPE_REPLACE_DIE),
            "VISION_TYPE_REPLACE_NO_NOTIFY" => ::std::option::Option::Some(VisionType::VISION_TYPE_REPLACE_NO_NOTIFY),
            "VISION_TYPE_BORN" => ::std::option::Option::Some(VisionType::VISION_TYPE_BORN),
            "VISION_TYPE_PICKUP" => ::std::option::Option::Some(VisionType::VISION_TYPE_PICKUP),
            "VISION_TYPE_REMOVE" => ::std::option::Option::Some(VisionType::VISION_TYPE_REMOVE),
            "VISION_TYPE_FISH_REFRESH" => ::std::option::Option::Some(VisionType::VISION_TYPE_FISH_REFRESH),
            "VISION_TYPE_FISH_BIG_SHOCK" => ::std::option::Option::Some(VisionType::VISION_TYPE_FISH_BIG_SHOCK),
            "VISION_TYPE_FISH_QTE_SUCC" => ::std::option::Option::Some(VisionType::VISION_TYPE_FISH_QTE_SUCC),
            "VISION_TYPE_CAPTURE_DISAPPEAR" => ::std::option::Option::Some(VisionType::VISION_TYPE_CAPTURE_DISAPPEAR),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [VisionType] = &[
        VisionType::VISION_TYPE_NONE,
        VisionType::VISION_TYPE_MEET,
        VisionType::VISION_TYPE_REBORN,
        VisionType::VISION_TYPE_REPLACE,
        VisionType::VISION_TYPE_WAYPOINT_REBORN,
        VisionType::VISION_TYPE_TYPE_MISS,
        VisionType::VISION_TYPE_DIE,
        VisionType::VISION_TYPE_GATHER_ESCAPE,
        VisionType::VISION_TYPE_REFRESH,
        VisionType::VISION_TYPE_TRANSPORT,
        VisionType::VISION_TYPE_REPLACE_DIE,
        VisionType::VISION_TYPE_REPLACE_NO_NOTIFY,
        VisionType::VISION_TYPE_BORN,
        VisionType::VISION_TYPE_PICKUP,
        VisionType::VISION_TYPE_REMOVE,
        VisionType::VISION_TYPE_FISH_REFRESH,
        VisionType::VISION_TYPE_FISH_BIG_SHOCK,
        VisionType::VISION_TYPE_FISH_QTE_SUCC,
        VisionType::VISION_TYPE_CAPTURE_DISAPPEAR,
    ];
}

impl ::protobuf::EnumFull for VisionType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("VisionType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            VisionType::VISION_TYPE_NONE => 0,
            VisionType::VISION_TYPE_MEET => 1,
            VisionType::VISION_TYPE_REBORN => 2,
            VisionType::VISION_TYPE_REPLACE => 3,
            VisionType::VISION_TYPE_WAYPOINT_REBORN => 4,
            VisionType::VISION_TYPE_TYPE_MISS => 5,
            VisionType::VISION_TYPE_DIE => 6,
            VisionType::VISION_TYPE_GATHER_ESCAPE => 7,
            VisionType::VISION_TYPE_REFRESH => 8,
            VisionType::VISION_TYPE_TRANSPORT => 9,
            VisionType::VISION_TYPE_REPLACE_DIE => 10,
            VisionType::VISION_TYPE_REPLACE_NO_NOTIFY => 11,
            VisionType::VISION_TYPE_BORN => 12,
            VisionType::VISION_TYPE_PICKUP => 13,
            VisionType::VISION_TYPE_REMOVE => 14,
            VisionType::VISION_TYPE_FISH_REFRESH => 15,
            VisionType::VISION_TYPE_FISH_BIG_SHOCK => 16,
            VisionType::VISION_TYPE_FISH_QTE_SUCC => 17,
            VisionType::VISION_TYPE_CAPTURE_DISAPPEAR => 18,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for VisionType {
    fn default() -> Self {
        VisionType::VISION_TYPE_NONE
    }
}

impl VisionType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<VisionType>("VisionType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x11SceneUpdate.proto\x12\rMualani.Guide\x1a\x1fWorldPlayerLocationNot\
    ify.proto\x1a\x12AvatarNotify.proto\"^\n\nMotionInfo\x12'\n\x03pos\x18\
    \x01\x20\x01(\x0b2\x15.Mualani.Guide.VectorR\x03pos\x12'\n\x03rot\x18\
    \x02\x20\x01(\x0b2\x15.Mualani.Guide.VectorR\x03rot\"\x9f\x01\n\x0fScene\
    AvatarInfo\x12\x10\n\x03uid\x18\x01\x20\x01(\rR\x03uid\x12\x13\n\x05av_i\
    d\x18\x02\x20\x01(\rR\x04avId\x12\x12\n\x04guid\x18\x03\x20\x01(\x04R\
    \x04guid\x12\x17\n\x07peer_id\x18\x04\x20\x01(\rR\x06peerId\x12\x16\n\
    \x06equips\x18\x05\x20\x03(\rR\x06equips\x12\x20\n\x0cskill_dep_id\x18\
    \x06\x20\x01(\rR\nskillDepId\"\x95\x01\n\x10SceneMonsterInfo\x12\x1d\n\n\
    monster_id\x18\x01\x20\x01(\rR\tmonsterId\x12\x19\n\x08group_id\x18\x02\
    \x20\x01(\rR\x07groupId\x12\x1b\n\tconfig_id\x18\x03\x20\x01(\rR\x08conf\
    igId\x12\x14\n\x05elite\x18\x07\x20\x01(\x08R\x05elite\x12\x14\n\x05owne\
    r\x18\x08\x20\x01(\rR\x05owner\"\x81\x01\n\x0cSceneNPCInfo\x12\x15\n\x06\
    npc_id\x18\x01\x20\x01(\rR\x05npcId\x12\x17\n\x07room_id\x18\x02\x20\x01\
    (\rR\x06roomId\x12&\n\x0fparent_quest_id\x18\x03\x20\x01(\rR\rparentQues\
    tId\x12\x19\n\x08block_id\x18\x04\x20\x01(\rR\x07blockId\"\x8e\x01\n\x0f\
    SceneGadgetInfo\x12\x1b\n\tgadget_id\x18\x01\x20\x01(\rR\x08gadgetId\x12\
    \x19\n\x08group_id\x18\x02\x20\x01(\rR\x07groupId\x12\x1b\n\tconfig_id\
    \x18\x03\x20\x01(\rR\x08configId\x12&\n\x0fowner_entity_id\x18\x04\x20\
    \x01(\rR\rownerEntityId\"\xd8\x05\n\nEntityInfo\x12-\n\x04type\x18\x01\
    \x20\x01(\x0e2\x19.Mualani.Guide.EntityTypeR\x04type\x12\x0e\n\x02id\x18\
    \x02\x20\x01(\rR\x02id\x12\x17\n\x04name\x18\x03\x20\x01(\tH\0R\x04name\
    \x88\x01\x01\x126\n\x06motion\x18\x04\x20\x01(\x0b2\x19.Mualani.Guide.Mo\
    tionInfoH\x01R\x06motion\x88\x01\x01\x12:\n\x05Props\x18\x05\x20\x03(\
    \x0b2$.Mualani.Guide.EntityInfo.PropsEntryR\x05Props\x12=\n\x06FProps\
    \x18\x06\x20\x03(\x0b2%.Mualani.Guide.EntityInfo.FPropsEntryR\x06FProps\
    \x12\x1d\n\nlife_state\x18\x07\x20\x01(\rR\tlifeState\x123\n\x02av\x18\n\
    \x20\x01(\x0b2\x1e.Mualani.Guide.SceneAvatarInfoH\x02R\x02av\x88\x01\x01\
    \x126\n\x03mon\x18\x0b\x20\x01(\x0b2\x1f.Mualani.Guide.SceneMonsterInfoH\
    \x03R\x03mon\x88\x01\x01\x122\n\x03npc\x18\x0c\x20\x01(\x0b2\x1b.Mualani\
    .Guide.SceneNPCInfoH\x04R\x03npc\x88\x01\x01\x12;\n\x06gadget\x18\r\x20\
    \x01(\x0b2\x1e.Mualani.Guide.SceneGadgetInfoH\x05R\x06gadget\x88\x01\x01\
    \x1aQ\n\nPropsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\rR\x03key\x12-\n\
    \x05value\x18\x02\x20\x01(\x0b2\x17.Mualani.Guide.PropertyR\x05value:\
    \x028\x01\x1a9\n\x0bFPropsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\rR\x03\
    key\x12\x14\n\x05value\x18\x02\x20\x01(\x02R\x05value:\x028\x01B\x07\n\
    \x05_nameB\t\n\x07_motionB\x05\n\x03_avB\x06\n\x04_monB\x06\n\x04_npcB\t\
    \n\x07_gadget\"\xa5\x01\n\x0bSceneUpdate\x12\x19\n\x05param\x18c\x20\x01\
    (\rH\0R\x05param\x88\x01\x01\x12:\n\x0bappear_type\x18\x07\x20\x01(\x0e2\
    \x19.Mualani.Guide.VisionTypeR\nappearType\x125\n\x08entities\x18\x01\
    \x20\x03(\x0b2\x19.Mualani.Guide.EntityInfoR\x08entitiesB\x08\n\x06_para\
    m\"~\n\x14SceneEntityDieUpdate\x12-\n\x04type\x18\x01\x20\x01(\x0e2\x19.\
    Mualani.Guide.VisionTypeR\x04type\x12\x19\n\x05param\x18c\x20\x01(\rH\0R\
    \x05param\x88\x01\x01\x12\x12\n\x04eids\x18\x0e\x20\x03(\x04R\x04eidsB\
    \x08\n\x06_param*\xa6\x02\n\nEntityType\x12\x0f\n\x0bENTITY_NONE\x10\0\
    \x12\x11\n\rENTITY_AVATAR\x10\x01\x12\x12\n\x0eENTITY_MONSTER\x10\x02\
    \x12\x0e\n\nENTITY_NPC\x10\x03\x12\x11\n\rENTITY_GADGET\x10\x04\x12\x11\
    \n\rENTITY_REGION\x10\x05\x12\x11\n\rENTITY_WEAPON\x10\x06\x12\x12\n\x0e\
    ENTITY_WEATHER\x10\x07\x12\x10\n\x0cENTITY_SCENE\x10\x08\x12\x0f\n\x0bEN\
    TITY_TEAM\x10\t\x12\x12\n\x0eENTITY_MASSIVE\x10\n\x12\x11\n\rENTITY_MP_L\
    VL\x10\x0b\x12\x14\n\x10ENTITY_PLAY_TEAM\x10\x0c\x12\x13\n\x0fENTITY_EYE\
    POINT\x10\r\x12\x0e\n\nENTITY_MAX\x10\x0e*\x93\x04\n\nVisionType\x12\x14\
    \n\x10VISION_TYPE_NONE\x10\0\x12\x14\n\x10VISION_TYPE_MEET\x10\x01\x12\
    \x16\n\x12VISION_TYPE_REBORN\x10\x02\x12\x17\n\x13VISION_TYPE_REPLACE\
    \x10\x03\x12\x1f\n\x1bVISION_TYPE_WAYPOINT_REBORN\x10\x04\x12\x19\n\x15V\
    ISION_TYPE_TYPE_MISS\x10\x05\x12\x13\n\x0fVISION_TYPE_DIE\x10\x06\x12\
    \x1d\n\x19VISION_TYPE_GATHER_ESCAPE\x10\x07\x12\x17\n\x13VISION_TYPE_REF\
    RESH\x10\x08\x12\x19\n\x15VISION_TYPE_TRANSPORT\x10\t\x12\x1b\n\x17VISIO\
    N_TYPE_REPLACE_DIE\x10\n\x12!\n\x1dVISION_TYPE_REPLACE_NO_NOTIFY\x10\x0b\
    \x12\x14\n\x10VISION_TYPE_BORN\x10\x0c\x12\x16\n\x12VISION_TYPE_PICKUP\
    \x10\r\x12\x16\n\x12VISION_TYPE_REMOVE\x10\x0e\x12\x1c\n\x18VISION_TYPE_\
    FISH_REFRESH\x10\x10\x12\x1e\n\x1aVISION_TYPE_FISH_BIG_SHOCK\x10\x11\x12\
    \x1d\n\x19VISION_TYPE_FISH_QTE_SUCC\x10\x12\x12!\n\x1dVISION_TYPE_CAPTUR\
    E_DISAPPEAR\x10\x13b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::WorldPlayerLocationNotify::file_descriptor().clone());
            deps.push(super::AvatarNotify::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(8);
            messages.push(MotionInfo::generated_message_descriptor_data());
            messages.push(SceneAvatarInfo::generated_message_descriptor_data());
            messages.push(SceneMonsterInfo::generated_message_descriptor_data());
            messages.push(SceneNPCInfo::generated_message_descriptor_data());
            messages.push(SceneGadgetInfo::generated_message_descriptor_data());
            messages.push(EntityInfo::generated_message_descriptor_data());
            messages.push(SceneUpdate::generated_message_descriptor_data());
            messages.push(SceneEntityDieUpdate::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(EntityType::generated_enum_descriptor_data());
            enums.push(VisionType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
